{"./":{"url":"./","title":"Part Zero. Introduction ","keywords":"","body":"Introduction 常用终端命令 $ gitbook install ./ $ gitbook build ./ .\\algorithm-notes.github.io\\docs $ gitbook serve Katex 语法 Inline math: {% math %}\\int_{-\\infty}^\\infty g(x) dx{% endmath %} Block math: {% math %} \\int_{-\\infty}^\\infty g(x) dx {% endmath %} 正文引用添加方式 > [!note|iconVisibility:hidden] > NOTE > [!tip|iconVisibility:hidden] > TIPS > [!warning|iconVisibility:hidden] > SUPPLEMENT > [!danger|iconVisibility:hidden] > CORE CONTENT "},"Part One/1指针.html":{"url":"Part One/1指针.html","title":"1 指针","keywords":"","body":"1 指针 1.1 快慢指针 [!danger|iconVisibility:hidden] 慢指针每次移动一格，快指针每次移动 kkk 格 【经典问题】弗洛伊德的兔子和龟 弗洛伊德的兔子和龟针对的是有环链表的问题，比如 主要解决两个问题： ① 判断有环无环 bool hasCycle(ListNode *head) { ListNode *tortoise = head; ListNode *hare = head; while(hare!=NULL && hare->next!=NULL) { tortoise = tortoise->next; hare = hare->next->next; if(tortoise==hare) return true; } return false; LeetCode 141.环形链表I ② 找到环的入口 ListNode *detectCycle(ListNode *head) { if(head==NULL) return NULL; ListNode *intersect = getintersect(head); if(intersect==NULL) return NULL; ListNode *ptr1 = head; ListNode *ptr2 = intersect; while(ptr1!=ptr2) { ptr1 = ptr1->next; ptr2 = ptr2->next; } return ptr1; LeetCode 142. 环形链表 II 【拓展】 但是如果就只问有环链表，显得太基础 (￣_,￣ ) 于是，就有了一些抽象有环链表的问题，但是这些问题大多数都有一个明显的特性，就是在移动的过程中会出现一个环，这个环可以是一组周期出现的数字，也可以就是沿线性表移动过程中出现的环 所以只要出现这个明显的特性就可以想到弗洛伊德的龟和兔子 LeetCode 202.快乐数 LeetCode 287. 寻找重复数 【经典问题】对链表中的结点进行操作 快慢指针还有一种常见的使用情况就是对链表中的结点进行操作。这时，快慢指针的移动方式可能因题而异，但最终的目的都是当快指针不能再移动时，慢指针将刚好到达期望的位置 比如取链表中间结点 题目描述 876. 链表的中间结点 class Solution { public: ListNode* middleNode(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while (fast != nullptr && fast->next != nullptr) { fast = fast->next->next; slow = slow->next; } return slow; } }; 题目描述 19. 删除链表的倒数第N个节点 解法 稍微需要注意的就是这里的慢指针应该停在倒数第 N 个结点的前一个，方便删除 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummyhead = new ListNode(-1); dummyhead->next = head; ListNode* slow = dummyhead; ListNode* fast = dummyhead; for (int i = 0;i next; while (fast!=nullptr) { slow = slow->next; fast = fast->next; } ListNode* delnode = slow->next; low->next = delnode->next; delete delnode; return dummyhead->next; } }; LeetCode 19. 删除链表的倒数第N个节点 LeetCode 876. 链表的中间结点 当然快慢指针的思想也可以用到数组的处理中，下面这道题 【经典问题】删除有序数组中的重复项 题目描述 26. 删除有序数组中的重复项 解法 我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就赋值给 slow 并让 slow 前进一步 这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果 class Solution { public: int removeDuplicates(vector& nums) { if (nums.size() == 0) return 0; int slow = 0, fast = 0; while (fast 【经典问题】删除排序链表中的重复元素 题目描述 83. 删除排序链表中的重复元素 解法 解法上都是类似的，我们可以通过下面的 GIF 加深下对算法执行过程的理解 class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (head == nullptr) return nullptr; ListNode* slow = head; ListNode* fast = head; while (fast != nullptr) { if (fast->val != slow->val) { slow->next = fast; slow = slow->next; } fast = fast->next; } slow->next = nullptr; return head; } }; 【经典问题】移除元素 题目描述 27. 移除元素 解法 解法也是类似的，注意我们这里是先给 nums[slow] 赋值然后再给 slow++，这样可以保证 nums[0..slow-1] 是不包含值为 val 的元素的，最后的结果数组长度就是 slow class Solution { public: int removeElement(vector& nums, int val) { int fast = 0, slow = 0; while (fast 类似的题目还有 283. 移动零 1.2 双指针 【典型问题分析——相交链表】 题目描述 LeetCode 160. 相交链表 解法分析 找到两个单链表相交的起始结点，比如下面链表的相交结点为 c1c1c1 算法的思路很简单，就是： 初始化 ha=headA,hb=headBha = headA, hb = headBha=headA,hb=headB，开始遍历 若 AAA 链短，hahaha 会先到达链表尾，当 hahaha 到达末尾时，重置 hahaha 为 headBheadBheadB；同样的，当 hbhbhb 到达末尾时，重置 hbhbhb 为 headAheadAheadA 当 hahaha 与 hbhbhb 相遇时，必然就是两个链表的交点 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *ha = headA, *hb = headB; while(ha != hb) { ha = ha==NULL?headB:ha->next; hb = hb==NULL?headA:hb->next; } return ha; 1.3 左右指针 1.3.1 二分法 左右指针最典型的一个用法就是二分法，但是吧，二分法思路很简单，细节是魔鬼 ━━∑(￣□￣*|||━━ 下面是摘自 《labuladong 的算法小抄》中的一首打油诗，可以帮助记忆二分搜索的细节 我们先给出二分法的框架，然后慢慢对应着上面的打油诗解释二分搜索 int binarySearch(vector nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] target) { right = ... } } return ...; } 两个细节： 不要出现 else，而是把所有情况用 else if 写清楚 我们使用 left+(right−left)/2left + (right - left) / 2left+(right−left)/2 而是 (left+right)/2(left + right) / 2(left+right)/2 ，主要考虑如果 leftleftleft 和 rightrightright 都很大时，那么直接相加就会爆掉 （1） 寻找一个数——基本二分搜索 int binarySearch(vector nums, int target) { int left = 0; int right = nums.size() - 1; // 猜数的时候，这里有变化 while(left target) right = mid - 1; } return -1; } 解释：搜索一个元素时，搜索区间两端闭 初始化时，right == nums.size()-1 其代表的搜索区间是 [left, right]，如果写成 right == nums.size() 则其代表的搜索区间是 [left, right) 解释：while 条件带等号，否则需要打补丁 while(left while(left while(...){ ... } return nums[left] == target ? left : -1; 解释：mid 必须要减一，因为区间两端闭 刚才明确了搜索区间这个概念，而且该算法的搜索区间是两端都闭的，即 [left, right]，那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？ 当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除 (2) 寻找左侧边界的二分搜索 考虑有序数组 nums = [1, 2, 2, 2, 3]，target = 2，如果我们想得到 target 的左侧边界，即索引 1，那么可以按照下面的代码进行处理 int left_bound(vector nums, int target) { if (nums.size() == 0) return -1; int left = 0; int right = nums.size(); // 注意 while (left target) right = mid; } if(left==nums.size()) return -1; return nums[left]==target? left:-1; } 解释：左闭右开最常见，其余逻辑便自明 搜索区间写成左闭右开只是一种普遍的方法，如果你想写成其他的形式也行 解释：while 要用小于号，这样才能不漏掉 用相同的方法分析，因为 right = nums.size() 而不是 nums.size() - 1，因此每次循环的『搜索区间』是 [left, right) 左闭右开 while(left 解释：if 相等别返回，利用 mid 锁边界 该算法之所以能搜索左侧边界，关键在于对于 nums[mid] == target 这种情况的处理： if (nums[mid] == target) right = mid; 可见，找到 target 时不要立即返回，而是缩小搜索区间的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的 解释：mid 加一或减一，要看区间开或闭 这个很好解释，因为我们的搜索区间是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right) 解释：索引可能超边界，if 检查最保险 我们先理解一下这个左侧边界有什么特殊含义： 比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个 再比如说 nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个 综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.size()]，所以我们简单添加两行代码就能在正确的时候 return -1： while (left (3) 寻找右侧边界 int right_bound(vector nums, int target) { if (nums.size() == 0) return -1; int left = 0, right = nums.size(); while (left target) { right = mid; } } if(left==0) return -1; return nums[left-1]==target? (left-1) : -1; } 解释两个点： 1. 为什么这个算法能够找到右侧边界？ 关键在于 if (nums[mid] == target) left = mid + 1; 当 nums[mid] == target 时，不要立即返回，而是增大搜索区间的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的 2. 为什么最后返回 left - 1 而不像左侧边界的函数，返回 left ？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对 首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，若非要体现右侧的特点，返回 right - 1 好了 至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断： if (nums[mid] == target) left = mid + 1; // 这样想: mid = left - 1 因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target 【经典问题】小张刷题计划 题目描述 LCP 12. 小张刷题计划 解法 给定一个数组，将其划分成 m 份，使得每份元素之和最大值最小】 常见算法流程 【经典问题】唯一重复数字 LeetCode 287. 寻找重复数 【经典问题】两数之和 II - 输入有序数组 题目描述 167. 两数之和 II - 输入有序数组 解法 class Solution { public: vector twoSum(vector& numbers, int target) { int left = 0, right = numbers.size() - 1; while (left target) right--; } return {-1, -1}; } }; 1.3.2 滑窗 滑窗也是一个典型的双指针问题，对于解决子串问题十分有效，大致的框架如下，其时间复杂度为 O(N)\\mathcal O(N)O(N)，比一般的暴力搜索方法要高效很多 算法框架——滑窗 int left = 0, right = 0; while (right 实际上滑窗问题的难点不在于算法的思路，而是各种细节问题，下面是一个更详细的 C++ 框架，体现了很多的实现细节问题 void SlidingWindow(string s, string t) { unordered_map need, window; for (char c : t) nedd[c]++; int left = 0, right = 0; int valid = 0; while (right 需要特别指出的有两点： 往往两个 ... 处所表示的左移右移更新操作是完全对称的 通过 debug 处的代码可以知道我们的窗口是 [left, right) 这样一个左开右闭的区间 【经典问题】最小覆盖子串 题目描述 76. 最小覆盖子串 解法 分两步解决： 不断增加 right 直到窗口包含 T 中的所有字符，此时我们得到的是一个可行解 停止增加 right，转而不断增加 lef 优化上面得到的可行解，直到窗口不再符合要求，每次增加 left 的时候就进行 新一轮的更新 重复上面两步，直到 right 达到 S 的尽头 接着，解释一下上面框架出现的 needs 和 windows，这两个哈希表其实就是计数器，needs 记录 T 中字符出现的次数，windows 记录窗口中对应 T 字符出现的次数 另外，我们再解释一下框架中还出现的一个标志变量 valid，valid 表示窗口中满足 need 条件的字符个数，如果 valid == need.size() 就说明窗口以满足条件 class Solution { public: string minWindow(string s, string t) { unordered_map need, window; for (auto c: t) need[c]++; int left = 0, right = 0; int valid = 0; // 记录最小覆盖子串的起始索引及长度 int start = 0, len = INT_MAX; while (right 【经典问题】字符串排列 题目描述 567. 字符串的排列 解法 如果明白上题了，这题就很简单，就是判断 s2 中是否存在一个 s1 子串，注意此时窗口应该比 s1 长才是一个可行解，然后左移来优化 class Solution { public: bool checkInclusion(string s1, string s2) { unordered_map need, window; for (auto c: s1) need[c]++; int left = 0, right = 0; int valid = 0; while (right = s1.size()) { if (valid == need.size()) return true; char d = s2[left]; left++; if (need.count(d)) { if(window[d] == need[d]) valid--; window[d]--; } } } return false; } }; 【经典问题】找所有字母异位词 题目描述 438. 找到字符串中所有字母异位词 解法 所谓的字母异位词都是噱头，其实就是 window 和 need 完全一致 class Solution { public: vector findAnagrams(string s, string p) { unordered_map need, window; for (char c: p) need[c]++; int left= 0, right = 0; int valid = 0; vector res; while (right = p.size()) { if (valid == need.size()) res.push_back(left); char d = s[left]; left++; if (need.count(d)) { if (window[d] == need[d]) valid--; window[d]--; } } } return res; } }; 【经典问题】无重复字符的最长子串 题目描述 3. 无重复字符的最长子串 解法 这道题不是完全套框架，但是也很简单，不需要维护 need 了，只用一个 window，当 window[c] > 1 说明窗口中存在重复字符，此时就应该滑动窗口了 class Solution { public: int lengthOfLongestSubstring(string s) { unordered_map window; int left = 0, right = 0; int res = 0; while (right 1) { char d = s[left]; left++; window[d]--; } res = max(res, right -left); } return res; } } 1.3.3 两数之和 两数之和的描述大概是这样的： 如果假设输入一个数组 nums 和一个目标和 target，请你返回 nums 中能够凑出 target 的两个元素的值，比如输入 nums = [5,3,1,6], target = 9，那么算法返回两个元素 [3,6]。可以假设只有且仅有一对儿元素可以凑出 target 不同于 LeetCode 1. 两数之和 的是我们这里返回的是两个数，当然返回索引也是一样的，没啥大区别。当然，双指针也可以解决，但是最好的方法是用 hash table，时间复杂度为 O(N)\\mathcal O(N)O(N)，空间复杂度为 O(N)\\mathcal O(N)O(N)，相当于牺牲一点空间换时间了 完整代码如下 class Solution { public: vector twoSum(vector& nums, int target) { unordered_map hash; for(int i=0;i 但是，为了和后面的 3Sum、4Sum 等问题对应起来，我们还是研究一下返回元素 这时的解题思路是：对 nums 排序，然后利用左右双指针，从两端相向而行就行了 vector twoSum(vector& nums, int target) { // 先对数组排序 sort(nums.begin(), nums.end()); // 左右指针 int lo = 0, hi = nums.size() - 1; while (lo target) { hi--; } else if (sum == target) { return {nums[lo], nums[hi]}; } } return {}; } 我们下面进行一些改动 如果 nums 中可能有多对元素之和都等于 target，返回所有和为 target 的元素对，其中不能出现重复 怎么处理呢？首先我们要明白重复产生的原因，如下图所示，比如说 nums = [1,1,1,2,2,3,3], target = 4，在排序之后我们可以看到重复的元素都会紧邻，而如果每次判断都只是左右元素相加等于 target 然后移动左右指针，那么必然产生很多重复 解决的办法也很简单，既然相同元素的是紧邻的，那么当给 sum == target 时，lo 和 hi 直接跳过所有重复的元素即可，如下所示 while (lo target) hi--; else { res.push_back({left, right}); // 跳过所有重复的元素 while (lo 完整的代码如下所示 vector> twoSumTarget(vector& nums, int target) { // nums 数组必须有序 sort(nums.begin(), nums.end()); int lo = 0, hi = nums.size() - 1; vector> res; while (lo target) { while (lo 这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 O(N)\\mathcal O(N)O(N)，而排序的时间复杂度是 O(NlogN)\\mathcal O(N\\log N)O(NlogN)，所以这个函数的时间复杂度是 O(NlogN)\\mathcal O(N\\log N)O(NlogN) 【经典问题】三数之和 题目描述 15. 三数之和 解法 简而言之，穷举，。现在我们想找和为 target 的三个数字，那么对于第一个数字，可能是什么？nums 中的每一个元素 nums[i] 都有可能 那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为 target - nums[i] 的两个数字，那就是 twoSum 函数解决的问题 下面的代码中我们实现了一个更通用的三数之和的版本，任意给定 target 我们都可以找到满足的结果 class Solution { public: vector> threeSum(vector& nums) { return threeSumTarget(nums, 0); } vector> threeSumTarget(vector& nums, int target){ sort(nums.begin(), nums.end()); int n = nums.size(); vector> res; for (int i = 0;i > tuples = twoSumTarget(nums, i + 1, target - nums[i]); for ( vector& t: tuples) { t.push_back(nums[i]); res.push_back(t); } while (i > twoSumTarget(vector& nums, int start, int target){ int lo = start, hi = nums.size() - 1; vector> res; while (lo target) { while( lo 值得注意的是，类似 twoSum，3Sum 的结果也可能重复，比如输入是 nums = [1,1,1,2,3], target = 6，结果就会重复 关键点在于，不能让第一个数重复，至于后面的两个数，我们复用的 twoSum函数会保证它们不重复。所以代码中必须用一个 while 循环来保证 3Sum 中第一个元素不重复 至此，3Sum 问题就解决了，时间复杂度不难算，排序的复杂度为 O(NlogN)\\mathcal O(N\\log N)O(NlogN)，twoSumTarget 函数中的双指针操作为 O(N)\\mathcal O(N)O(N)，threeSumTarget 函数在 for 循环中调用 twoSumTarget 所以总的时间复杂度就是 O(NlogN+N2)=O(N2)\\mathcal O(NlogN + N^2) =\\mathcal O(N^2)O(NlogN+N​2​​)=O(N​2​​) 【经典问题】四数之和 问题描述 18. 四数之和 解法 4Sum 完全就可以用相同的思路：穷举第一个数字，然后调用 3Sum 函数计算剩下三个数，最后组合出和为 target 的四元组。是不是很暴力，是不是很意外？没事官方题解也是这样的，到这份上这个算法的时间复杂度自然也就是 O(N3)\\mathcal O(N^3)O(N​3​​) 了 class Solution { public: vector> fourSum(vector& nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); vector> res; for (int i = 0;i > tuples = threeSumTarget(nums, i + 1, (long) target - nums[i]); for ( vector& t: tuples) { t.push_back(nums[i]); res.push_back(t); } while (i > threeSumTarget(vector& nums, int start, long target){ int n = nums.size(); vector> res; for (int i = start;i > tuples = twoSumTarget(nums, i + 1, (long) target - nums[i]); for ( vector& t: tuples) { t.push_back(nums[i]); res.push_back(t); } while (i > twoSumTarget(vector& nums, int start, long target){ int lo = start, hi = nums.size() - 1; vector> res; while (lo target) { while( lo > fourSum(vector& nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); vector> res; for (int i = 0;i > tuples = threeSumTarget(nums, i + 1, (long) target - nums[i]); for ( vector& t: tuples) { t.push_back(nums[i]); res.push_back(t); } while (i > threeSumTarget(vector& nums, int start, long target){ int n = nums.size(); vector> res; for (int i = start;i > tuples = twoSumTarget(nums, i + 1, (long) target - nums[i]); for ( vector& t: tuples) { t.push_back(nums[i]); res.push_back(t); } while (i > twoSumTarget(vector& nums, int start, long target){ int lo = start, hi = nums.size() - 1; vector> res; while (lo target) { while( lo 【经典问题】n 数之和 最后我们给一个模板，4Sum 问题该函数调函数已经非常冗余，我们来精简一下，一套模板搞定 nSum 问题 /* 注意：调用这个函数之前一定要先给 nums 排序 */ vector> nSumTarget( vector& nums, int n, int start, int target) { int sz = nums.size(); vector> res; // 至少是 2Sum，且数组大小不应该小于 n if (n target) { while (lo 2 时，递归计算 (n-1)Sum 的结果 for (int i = start; i > sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]); for (vector& arr : sub) { // (n-1)Sum 加上 nums[i] 就是 nSum arr.push_back(nums[i]); res.push_back(arr); } while (i 一定注意，调用这个 nSumTarget 函数之前一定要先给 nums 数组排序，因为 nSum 是一个递归函数，如果在 nSumTarget 函数里调用排序函数，那么每次递归都会进行没有必要的排序，效率会非常低 比如说现在我们写 LeetCode 上的 4Sum 问题： vector> fourSum(vector& nums, int target) { sort(nums.begin(), nums.end()); // n 为 4，从 nums[0] 开始计算和为 target 的四元组 return nSumTarget(nums, 4, 0, target); } 其他问题 左右指针的核心是两个指针分别从数组的两端向中心靠拢，这种面对面靠近的特点也给我们在处理一些原地翻转的问题上带来了方便 【经典问题】反转字符串 题目描述 344. 反转字符串 解法 class Solution { public: void reverseString(vector& s) { int left = 0, right = s.size() - 1; while (left 还有一类使用左右指针的方式是，由中心向两端扩展，例如最长子串使用的中心扩展算法即是一种 【经典问题】反转字符串 题目描述 344. 反转字符串 解法 回文串的的长度可能是奇数也可能是偶数，如果其长度为奇数，则它有一个中心字符；如果其长度为偶数，那么它有两个中心字符 那么最长回文串的问题，其大致思路就可以描述为 for 0 怎么找回文串呢？很简单，这就是采用左右指针从从中心往两端走，详细看下面的 palindorme 函数 class Solution { public: string longestPalindrome(string s) { string res = \"\"; int start = 0, end = 0; for (int i = 0; i end - start) { start = left1; end = right1; } if (right2 - left2 > end - start) { start = left2; end = right2; } } return s.substr(start, end - start + 1); } pair palindorme(string s, int l, int r){ while(l >= 0 && r "},"Part One/2回溯.html":{"url":"Part One/2回溯.html","title":"2 回溯","keywords":"","body":"2 回溯 【核心思想】解决一个回溯问题，实际上就是一个决策树的变脸过程 所以，我们对于一个回溯问题只考虑 3 个问题， 『路径』：已经作出的选择 『选择列表』：当前可以做的选择 『结束条件』：到达决策树底层，无法再做选择的条件 【算法框架】 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径，选择列表) 撤销选择 核心是 for 循环里面的递归如何处理，在递归调用之前做选择，在递归调用之后撤销选择 【经典问题分析——全排列问题】 这里作出了一个简化，我们讨论的全排列的问题不包含重复的数字 假如给定的序列为 [1, 2, 3]，则很容易知道全排列的回溯树如下图所示 我们也称这棵回溯树是决策树，因为我们在每个结点上都会作出一种决策，比如说我们在红色的结点上，我们可以选择 1 的分支，也可以选择 3 的分支 然后我们解释一下什么是选择列表和路径，看下下面的图很容易就理解 结合树的遍历就很容易理解，回溯函数其实就是一个游走指针，遍历整个回溯树，不是很理解的话看下下面的图吧 回溯算法的一大特点是，不存在像动态规划一样的重叠子问题可以优化，所以回溯算法就是纯暴力穷举，复杂度一半都很高 【经典问题分析——N 皇后问题】 题目描述 51. N 皇后 解法 N 皇后问题是一个经典的回溯问题，按照上面的描述，我们需要确定三个东西， 路径：board 中小于 row 的对那些已经成功放置了皇后的行 选择列表：第 row 行的所有列都是放置皇后的选择 结束条件：row 超过 board 的最后一行 明确了这三点我们就很容易写出解决 N 皇后问题的回溯算法啦 class Solution { public: vector> res; vector> solveNQueens(int n) { vector board(n, string(n, '.')); backtrace(board, 0); return res; } void backtrace(vector& board, int row){ if (row == board.size()) { res.push_back(board); return; } int n = board[row].size(); for (int col = 0; col & board, int row, int col){ int n = board.size(); // Check for col for (int i = 0; i = 0 && j = 0 && j >=0; i--, j--) if (board[i][j] == 'Q') return false; return true; } }; 但是有些时候我们可能只需要一种可行的解法就行，而避免找出所有可行解是假复杂度太高。此时，简单修改一下代码就好 bool backtrace(vector& board, int row){ if (row == board.size()) { res.push_back(board); return true; } int n = board[row].size(); for (int col = 0; col 排列组合问题 ① 元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次 backtrack 核心代码如下： /* 组合/子集问题回溯算法框架 */ void backtrack(vector nums, int start) { // 回溯算法标准框架 for (int i = start; i nums) { for (int i = 0; i 详细题目可参考： LeetCode 78. 子集 LeetCode 77. 组合 LeetCode 46. 全排列 ② 元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次，其关键在于排序和剪枝 backtrack 核心代码如下： sort(nums.begin(), nums.end()); /* 组合/子集问题回溯算法框架 */ void backtrack(vector nums, int start) { // 回溯算法标准框架 for (int i = start; i start && nums[i] == nums[i - 1]) { continue; } // 做选择 track.push_back(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.pop_back(); } } sort(nums.begin(), nums.end()); /* 排列问题回溯算法框架 */ void backtrack(vector nums) { for (int i = 0; i 0 && nums[i] == nums[i - 1] && !used[i - 1]) { continue; } // 做选择 used[i] = true; track.push_back(nums[i]); backtrack(nums); // 取消选择 track.pop_back(); used[i] = false; } } 详细题目可参考： LeetCode 90. 子集 II LeetCode 40. 组合总和 II LeetCode 47. 全排列 II ③ 元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次，只要删掉去重逻辑即可 backtrack 核心代码如下： /* 组合/子集问题回溯算法框架 */ void backtrack(vector nums, int start) { // 回溯算法标准框架 for (int i = start; i nums) { for (int i = 0; i 详细题目可参考： LeetCode 39. 组合总和 "},"Part One/3搜索.html":{"url":"Part One/3搜索.html","title":"3 搜索","keywords":"","body":"3 搜索 3.1 BFS 我们脱离开树来说一说 BFS 和 DFS，它们两者最大的区别就在于：『BFS 找到的路径一定是最短的， 代价是空间复杂度比 DFS 高很多』 这句话很关键，想想树的层次遍历和先序 / 后续遍历很容易就理解关于空间复杂度的描述；再想想不带权值的无向图中找起终点的最短路径，显然是调用 BFS 最简单，这样也很容易理解对路径最短的描述了 研究搜索的问题，包括树，我们处理的数据结构都是图，这一点是十分明确的 下面我们就直接给出算法框架 【算法框架】 def BFS(start, target): q = [] visited = set() q.append(start) visited.add(start) step = 0 while q: n = len(q) for _ in range(n): cur = q.pop(0) if cur is target: return step for x in cur.adj(): q.append(x) visited.add(x) step += 1 我们还是从树的问题说起，因为这是最经典，然后再给出一道实际问题抽象成图处理的问题 【经典问题分析——二叉树的最小深度】 题目描述 111. 二叉树的最小深度 解法 其实这道题超级简单，就是层遍历，只要当前层出现叶结点了就可以提前结束 class Solution { public: int minDepth(TreeNode* root) { if (!root) return 0; return BFS(root); } int BFS(TreeNode* root){ queue q; int depth = 1; q.emplace(root); while (!q.empty()) { int n = q.size(); for (int i = 0; i left && !cur->right) return depth; if (cur->left) q.emplace(cur->left); if (cur->right) q.emplace(cur->right); } depth++; } return -1; } }; 当然这段道题也可以用 DFS 解，『DFS 同样可以寻找最短路径』，做法就是：递归的处理每一个结点，分别计算每一个非叶子结点的左右子树的最小叶子节点深度 【经典问题分析——打开转盘锁】 题目描述 752. 打开转盘锁 解法 这道题说起来不难，把穷举每种情况的过程想成是一棵搜索树，出现重复的分支不要、出现 deadends 的分支不要，剪完枝后在搜索树上早最小，不就是 BFS 对于两种剪枝的情况，只要设一个 visited 集合就好了，先将 deadends 插入到 visited 中，自然就不会出现关于 deaends 的分支了 另外要说明的一个点是如何模拟转盘上下拨动一位，我们可以使用数学表达式 $NeighbourNums = (Num\\pm1 + 10)\\%10$ class Solution { public: int openLock(vector& deadends, string target) { unordered_set visited; visited.insert(deadends.begin(), deadends.end()); if (visited.count(\"0000\")) return -1; int ans = 0; queue q; q.push(\"0000\"); while (!q.empty()) { int n = q.size(); for (int i = 0; i 3.2 双向 BFS 优化 BFS 算法有一种稍微高级一点点的优化思路：双向 BFS，可以进一步提高算法的效率 区别： 传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和重点同时开始扩散，当两边有交集的时候停止 我们看两幅图来理解一下为什么双向 BFS 会快一些 很明显在第一幅图中，按照传统的 BFS 算法我们将会遍历整棵树才能得出结果；而双向 BFS 其实只遍历到树的一半就出现了交集，这是通过简单的加法我们就可以得出最短距离，这就是双向 BFS 快一些的原因 不过，双向 BFS 也有局限——我们必须提前知道终点的位置 【经典问题分析——打开转盘锁】 题目描述 752. 打开转盘锁 解法 对于二叉树的最小深度，因为我们不能事先知道终点的位置，所以没有办法使用双向 BFS 进行优化。而打开转盘锁问题不一样，我们知道确切的终点，于是将代码稍加修改就好了 class Solution { public: int openLock(vector& deadends, string target) { set deads; set q1; set q2; set visited; int step = 0; for(auto s: deadends) deads.insert(s); q1.insert(\"0000\"); q2.insert(target); while(!q1.empty() && !q2.empty()) { set tmp; for(auto cur: q1) { if(deads.count(cur)) continue; if(q2.count(cur)) return step; visited.insert(cur); for(int j = 0; j 注意，双向 BFS 不再使用队列，而是使用哈希表方便快速判断两个集合是否有交集 另外的一个技巧是，交换 q1 和 q2 的内容，这时只要默认扩散 q1 就相当于轮流扩散 对于双向 BFS 还有一个优化，就是在 while 循环开始时做一个判断 // ... while (!q1.empty() && !q2.empty()) { if (q1.size() > q2.size()) { // 交换 q1 和 q2 temp = q1; q1 = q2; q2 = temp; } // ... } 按照 BFS 的逻辑，队列（集合）中的元素越多，扩散后新的队列（集合）的元素就越多。在双向 BFS 中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度也会慢一些，效率就会高一些 强调一点： 无论传统 BFS 还是双向 BFS， 无论做不做优化， 从大 O 衡量标准来看， 时间复杂度都是⼀样的。 只能说双向 BFS 是⼀种 trick， 算法运行的速度会相对快⼀点 3.3 二维矩阵的 DFS 下面我们先直接给出二维矩阵的 DFS 递归框架，不难，就是在一个节点的上下左右进行递归 【算法框架】 // 二维矩阵遍历框架 void dfs(vector> grid, int i, int j, vector visited) { int m = grid.size(), n = grid[0].size(); if (i = m || j >= n) { // 超出索引边界 return; } if (visited[i][j]) { // 已遍历过 (i, j) return; } // 前序：进入节点 (i, j) visited[i][j] = true; dfs(grid, i - 1, j); // 上 dfs(grid, i + 1, j); // 下 dfs(grid, i, j - 1); // 左 dfs(grid, i, j + 1); // 右 // 后序：离开节点 (i, j) // visited[i][j] = true; } 在处理二维数组时我们有一个小技巧就是使用方向数组来处理上下左右的遍历，这时框架还是相似的 // 方向数组，分别代表上、下、左、右 vector> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}}; void dfs(vector> grid, int i, int j, vector visited) { int m = grid.size(), n = grid[0].size(); if (i = m || j >= n) { // 超出索引边界 return; } if (visited[i][j]) { // 已遍历过 (i, j) return; } // 进入节点 (i, j) visited[i][j] = true; // 递归遍历上下左右的节点 for (auto d : dirs) { int next_i = i + d[0]; int next_j = j + d[1]; dfs(grid, next_i, next_j); } // 离开节点 (i, j) // visited[i][j] = true; } 二维矩阵的 DFS 最好解决的就是各种岛屿问题，我们下面举例看下。关于岛屿的问题还有另外一些常用的方法，如 BFS，这个和 DFS 差别不大，就是递归的顺序不一样；还有一种做法是使用并查集，这就牵扯到并查集框架的问题，我们在另外一部分算法模板中再详细介绍 【经典问题分析——岛屿数量】 题目描述 200. 岛屿数量 解法 我们把遍历过的岛屿块就直接用 0 标记了，这种算法叫做 FloodFill，主要就是省事，避免维护一个 visited 数组 class Solution { public: int numIslands(vector>& grid) { int res = 0; int m = grid.size(), n = grid[0].size(); for (int i = 0; i >& grid, int i,int j) { int m = grid.size(), n = grid[0].size(); if (i = m || j >= n) return; if (grid[i][j] == '0') return; grid[i][j] = '0'; dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } }; 【经典问题分析——统计封闭岛屿的数目】 题目描述 1254. 统计封闭岛屿的数目 解法 注意这道题在符号上对岛屿和海洋的定义是不同的，另外所有在二位矩阵边界上的岛屿都不可能是被海包围的孤岛，抓住这两点问题就解决了 class Solution { public: int closedIsland(vector>& grid) { int m = grid.size(), n = grid[0].size(); for (int j = 0; j >& grid, int i,int j){ int m = grid.size(), n = grid[0].size(); if (i = m || j >= n) return; if (grid[i][j] == 1) return; grid[i][j] = 1; dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } }; 【经典问题分析——岛屿的最大面积】 题目描述 695. 岛屿的最大面积 解法 这道题主要就是在 DFS 的时候添加一个计数，方法还是一样 FloodFill 算法 class Solution { public: int maxAreaOfIsland(vector>& grid) { int res = 0; int m = grid.size(), n = grid[0].size(); for (int i = 0; i tmp ? res : tmp; } } return res; } int dfs(vector>& grid, int i,int j){ int m = grid.size(), n = grid[0].size(); if (i = m || j >= n) return 0; if (grid[i][j] == 0) return 0; grid[i][j] = 0; return dfs(grid, i + 1, j) + dfs(grid, i, j + 1) + dfs(grid, i - 1, j) + dfs(grid, i, j - 1) + 1; } }; 【经典问题分析——统计子岛屿】 题目描述 1905. 统计子岛屿 解法 子岛屿的说法换一下这道题就没什么难点了，如果 2 中存在一片陆地，在 1 中对应位置是海水，那么就把 2 中这个岛屿淹了，最后 2 中剩下的岛屿自然是 1 的子岛屿 class Solution { public: int countSubIslands(vector>& grid1, vector>& grid2) { int m = grid1.size(), n = grid1[0].size(); for (int i = 0; i >& grid, int i,int j){ int m = grid.size(), n = grid[0].size(); if (i = m || j >= n) return; if (grid[i][j] == 0) return; grid[i][j] = 0; dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); } }; 3.4 二叉树的遍历 前面讲过 BFS、DFS，这些都是树和图中常用的搜索方法。这一节我们主要来讲一下二叉树的搜索。一般在二叉树里面我们不说深搜、广搜，而是说先序后序或中序遍历，每种遍历方法不同的是结点在遍历中的访问时间， 下面给出一张图来回忆一下，熟悉数据结构的都不陌生，请时刻记住这张图，它是你选择不同遍历方法解题的核心 我们这里做一个简单的总结： 一般不是特定中序或后序具有更大优势的情况下，我们都采用前序遍历，写起来方便易读 中序一般用在二叉搜索树上，这时遍历的结果会是一个有序数组 后序一般用在递归上，如果发现题目和子树有关，那大概率就要在后序位置写代码 一般来说，二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着回溯算法核心框架和动态规划核心框架 一种通用的思考过程是：是否可以通过遍历一遍二叉树得到答案？如果不能的话，是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？ 二叉树的最大深度这道题就是典型的题目，可以通过两种思路解决 【经典问题分析——二叉树的最大深度】 题目描述 104. 二叉树的最大深度 解法 我们可以通过一次遍历用一个外部变量记录每个结点所在的深度，由此就可以得到最大的深度 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { int res = 0, depth = 0; traverse(root, res, depth); return res; } void traverse(TreeNode* root, int& res, int& depth){ if (root == nullptr) { res = res > depth ? res : depth; return; } depth++; traverse(root->left, res, depth); traverse(root->right, res, depth); depth--; } }; 同时，我们也可以按照动态规划的思路来做，一棵二叉树的最大深度可以通过每棵子树的最大高度推出 class Solution { public: int maxDepth(TreeNode* root) { if (root == nullptr) return 0; int left_max = maxDepth(root->left); int right_max = maxDepth(root->right); return max(left_max, right_max) + 1; } }; 我们再看一道利用后续遍历递归的题目 【经典问题分析——二叉树中的最大路径和】 题目描述 124. 二叉树中的最大路径和 解法 class Solution { public: int maxPathSum(TreeNode* root) { if (root == nullptr) return 0; int res = INT_MIN; onSideMax(root, res); return res; } int onSideMax(TreeNode* root, int& res){ if (root == nullptr) return 0; int left_max_sum = max(0, onSideMax(root->left, res)); int right_max_sum = max(0, onSideMax(root->right, res)); int path_max_sum = root -> val + left_max_sum + right_max_sum; res = max(res, path_max_sum); return max(left_max_sum, right_max_sum) + root -> val; } }; 最后，我们讨论下二叉树的层遍历，算法框架如下，和 BFS 是类似的 // 输入一棵二叉树的根节点，层序遍历这棵二叉树 void levelTraverse(TreeNode* root) { if (root == nullptr) return; queue q; q.push(root); // 从上到下遍历二叉树的每一层 while (!q.empty()) { int sz = q.size(); // 从左到右遍历每一层的每个节点 for (int i = 0; i left != null) { q.push(cur->left); } if (cur->right != null) { q.push(cur-?right); } } } } 这里面 while 循环和 for 循环分管从上到下和从左到右的遍历： 【经典问题分析——在每个树行中找最大值】 题目描述 515. 在每个树行中找最大值 解法 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector largestValues(TreeNode* root) { vector res; if (root == nullptr) return res; queue q; q.push(root); while (!q.empty()){ int n = q.size(); int level_max = INT_MIN; for (int i = 0; i val); if (tmp->left) q.push(tmp->left); if (tmp->right) q.push(tmp->right); } res.push_back(level_max); } return res; } }; 3.5 二叉树的遍历：递归改迭代 递归改迭代其实就是模拟计算机通过栈实现递归，如果在前序遍历的位置入栈，后序遍历的位置出栈，stk 中的节点变化情况就反映了 traverse 函数的递归过程（绿色节点就是被压入栈中的节点，灰色节点就是弹出栈的节点）： 简单说就是这样一个流程： 1、拿到一个节点，就一路向左遍历（因为 traverse(root->left) 排在前面），把路上的节点都压到栈里 2、往左走到头之后就开始退栈，看看栈顶节点的右指针，非空的话就重复第 1 步 代码框架如下所示，同时下面代码注释的部分也完成了二叉树的后序遍历 stack stk; void pushLeftBranch(TreeNode* cur){ while (cur != nullptr) { /*******************/ /** 前序遍历操作位置 **/ /*******************/ stk.push(cur); cur = cur->left; } } vector traverse(TreeNode* root) { // vector res; TreeNode* visited = new TreeNode(-1); pushLeftBranch(root); while (!stk.empty()) { TreeNode* p = stk.top(); if ((p->left == nullptr || p->left == visited) && p->right != visited) { /*******************/ /** 中序遍历操作位置 **/ /*******************/ pushLeftBranch(p->right); } if (p->right == nullptr || p->right == visited) { /*******************/ /** 后序遍历操作位置 **/ /*******************/ // res.push_back(p->val); visited = p; stk.pop(); } } return res; } 我们用 visited 指针记录最近一次遍历完的子树根节点（最近一次 pop 出栈的节点），我们可以根据对比 cur 的左右指针和 visited 是否相同来判断节点 cur 的左右子树是否被遍历过，进而分离出前中后序的代码位置 "},"Part One/4前缀和.html":{"url":"Part One/4前缀和.html","title":"4 前缀和","keywords":"","body":"4 前缀和 一维前缀和 前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和 我们以下面这道题来讲述一维前缀和的思想 【经典问题】区域和检索 - 数组不可变 题目描述 303. 区域和检索 - 数组不可变 解法 前缀和的核心思路是我们 new 一个新的数组 preSum 出来，preSum[i] 记录 nums[0..i-1] 的累加和，看图 10 = 3 + 5 + 2： 看这个 preSum 数组，如果我想求索引区间 [1, 4] 内的所有元素之和，就可以通过 preSum[5] - preSum[1] 得出。 这样，sumRange 函数仅仅需要做一次减法运算，避免了每次进行 for 循环调用，最坏时间复杂度为常数 $\\mathcal O(1)$ class NumArray { private: vector presum; public: NumArray(vector& nums) { presum.resize(nums.size() + 1); for (int i = 1;i sumRange(left,right); */ 二维前缀和 二维前缀和矩阵中的每一个格子记录的是「以当前位置为区域的右下角（区域左上角恒定为原数组的左上角）的区域和」，那么二维前缀和矩阵就可以按照如下图所示的方法生成 因此当我们要求 $(x_1, y_1)$ 作为左上角，$(x_2, y_2)$ 作为右下角 的区域和的时候，可以直接利用前缀和数组快速求解： sum[x2][y2]−sum[x1−1][y2]−sum[x2][y1−1]+sum[x1−1][y1−1]\r sum[x_2][y_2] - sum[x_1 - 1][y_2] - sum[x_2][y_1 - 1] + sum[x_1 - 1][y_1 - 1]\r sum[x​2​​][y​2​​]−sum[x​1​​−1][y​2​​]−sum[x​2​​][y​1​​−1]+sum[x​1​​−1][y​1​​−1] 【经典问题】二维区域和检索 - 矩阵不可变 304. 二维区域和检索 - 矩阵不可变 的答案可以视为二维前缀和的一个框架 class NumMatrix { public: vector> sum; NumMatrix(vector>& matrix) { int n = matrix.size(); if (n > 0) { int m = matrix[0].size(); sum.resize(n + 1, vector(m + 1, 0)); for (int i = 1 ; i sumRegion(row1,col1,row2,col2); */ 【经典问题】图片平滑器 题目描述 661. 图片平滑器 解法 这道题我们定义 $(a, b) = (i - 1, j - 1)$ 和 $(c, d) = (i + 1, j + 1)$ 表示每个九宫格的左上和右下，为了防止超出原矩阵，我们需要将 $(a, b)$ 和 $(c, d)$ 与边界做比较 同时，我们一般习惯对 $n\\times m$ 的矩阵创建 $(n+1)\\times(m+1)$ 的二维前缀和矩阵，这里考虑到下图红色矩阵的情况，我们将二维前缀和矩阵申请为 $(n+2)\\times(m+2)$ class Solution { public: vector> imageSmoother(vector>& img) { int n = img.size(), m = img[0].size(); vector> sum(n + 2, vector(m + 2, 0)); for (int i = 1; i > ans(n, vector(m)); for (int i = 0; i 【经典问题】和为 K 的子数组 问题描述 560. 和为 K 的子数组 解法 借助前缀和技巧很容易写出一个解法： int subarraySum(vector& nums, int k) { int n = nums.size(); // 构造前缀和 vector preSum(n + 1); preSum[0] = 0; for (int i = 0; i 这个解法的时间复杂度 $\\mathcal O(N^2)$，空间复杂度 $\\mathcal O(N)$，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低 注意前面的解法有嵌套的 for 循环，时间复杂度高主要受这里的影响 for (int i = 1; i 第二层 for 循环在干嘛呢？翻译一下就是，在计算，有几个 j 能够使得 preSum[i] 和 preSum[j] 的差为 k。毎找到一个这样的 j，就把结果加一 我们可以把 if 语句里的条件判断移项，这样写： if (preSum[j] == preSum[i] - k) res++; 那么优化的思路就是：我直接记录下有几个preSum[j]和preSum[i] - k相等，直接更新结果，就避免了内层的 for 循环。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数 class Solution { public: int subarraySum(vector& nums, int k) { int n = nums.size(); unordered_map hash; hash[0] = 1; int res = 0, presum_i = 0; for (int i = 0; i 比如下图，我们的 i 已经走到了数组最后一个元素，前缀和 sum0_i（也即代码中的 presume_i）是 13，那么我们要找的就是 presum_j 出现的次数，也即前缀和 8 出现过的次数 我们可以看到第一个 8 出现在 presum[2]，那么 presum[6] - presum[2] 表示的就是区间 nums[2, 5] 刚好是一个和为 5 的区间，同理 presum[4] 也等于 8 这样，就把时间复杂度降到了 $\\mathcal O(N)$，是最优解法了 "},"Part One/5差分数组.html":{"url":"Part One/5差分数组.html","title":"5 差分数组","keywords":"","body":"5 差分数组 本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减 比如说，我给你输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给… 一通操作猛如虎，然后问你，最后 nums 数组的值是什么？ 常规的思路很容易，你让我给区间 nums[i..j] 加上 val，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 $\\mathcal O(N)$，由于这个场景下对 nums 的修改非常频繁，所以效率会很低下 这里就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造一个 diff 差分数组，diff[i] 就是 nums[i] 和 nums[i-1] 之差 通过这个 diff 差分数组是可以反推出原始数组 nums 的，代码逻辑如下： vector res = new int[diff.size()]; // 根据差分数组构造结果数组 res[0] = diff[0]; for (int i = 1; i 这样构造差分数组 diff，就可以快速进行区间增减的操作，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可： 原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于nums[j+1..]所有元素再减 3，那综合起来，是不是就是对 nums[i..j] 中的所有元素都加 3 了？ 只要花费 $\\mathcal O(1)$ 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果 class Difference { private: vector diff; public: Difference(vector& nums){ diff.resize(nums.size()); diff[0] = nums[0]; for (int i = 1; i result(){ vector res(diff.size()); res[0] = diff[0]; for (int i = 1; i 【经典问题】航班预订统计 题目描述 1109. 航班预订统计 解法 题目的意思就是给一组全 0 的 nums，在上面反复进行区间加法，问一顿操作最后的 nums 数组是多少 class Difference { ... }; class Solution { public: vector corpFlightBookings(vector>& bookings, int n) { vector nums(n, 0); Difference df(nums); for (auto tuple: bookings) { int i = tuple[0] - 1, j = tuple[1] - 1, val = tuple[2]; df.increment(i, j, val); } return df.result(); } }; 【经典问题】拼车 题目描述 1094. 拼车 解法 思路还是和上题一样的，现在我们的 nums 数组表示行驶的公里数，通过 0 可知最大公里数为 1000，那么我们将 nums 数组的长度设置为 1001 即可，我们的目的是保证 nums 上任何一个元素都小于 capacity，这样就可以保证汽车在整个行驶过程中都没有超载 class Difference { ... }; class Solution { public: bool carPooling(vector>& trips, int capacity) { vector nums(1001, 0); Difference df(nums); for (auto trip: trips){ // 第 trip[1] 站乘客上车，第 trip[2] 站乘客已经下车， // 即乘客在车上的区间是 [trip[1], trip[2] - 1] int val = trip[0], i = trip[1], j = trip[2] - 1; df.increment(i, j, val); } vector res = df.result(); for (int i = 0; i "},"Part One/6排序.html":{"url":"Part One/6排序.html","title":"6 排序","keywords":"","body":"6 排序 归并排序 以往讲归并排序都是两两合在一起保证一个大小顺序，但是所有的递归算法，本质上都是在遍历一棵树，一棵递归树，然后在结点（前中后序位置）上执行代码，告诉每个结点主要做什么。所以，我们可以对归并排序框架作出如下的解读 【算法框架】 void MergeSort(vector& nums, int low, int high) { if (low == high) return; int mid = low + (high - low) / 2; // 处理左半边 MergeSort(nums, low, mid); // 处理右半边 MergeSort(nums, mid + 1, high); // 后续位置 // 将两个处理好的半边合并在一起 merge(nums, low, mid, high); } // 将有序数组 nums[low, ..., mid] 和 nums[mid + 1, ..., high] // 合并为有序数组 nums[low, ..., high] void merge(vector& nums, int low, int mid, int high){ vector temp(nums.size()); for (int i = low; i temp[j]) nums[p] = temp[j++]; else nums[p] = temp[i++]; } } 过程如下所示，我们都知道归并排序的时间复杂度是 $\\mathcal O(N\\log N)$，从下面图也可以看的出来这个递归树的高度为 $\\log N$，其中每层的元素个数就是原始数组的长度 $N$ 关于双指针合并数组，可以参考下图 【经典问题】315. 计算右侧小于当前元素的个数 题目描述 315. 计算右侧小于当前元素的个数 解法 因为在排序过程中，每个元素的索引位置会不断改变，所以我们用一个 pair 来记录每个元素及其在原始数组 nums 中的索引，以便 count 数组记录每个元素之后小于它的元素个数 class Solution { private: vector count; vector> tmp; void merge(vector>& arr, int low, int mid, int high){ for (int i = low; i tmp[j].first) arr[p] = tmp[j++]; else { arr[p] = tmp[i++]; count[arr[p].second] += j - mid - 1; } } } void sort(vector>& arr, int low, int high){ if (low == high) return; int mid = low + (high - low) / 2; sort(arr, low, mid); sort(arr, mid + 1, high); merge(arr, low, mid, high); } public: vector countSmaller(vector& nums) { int n = nums.size(); tmp.resize(n); count.resize(n); vector> pairs; for (int i = 0; i res; for (int c: count) res.emplace_back(c); return res; } }; 快速排序 我们先直接给出快速排序的框架，你看是不是和归并排序一样——和二叉树的变累了代码很像 【算法框架】 void QuickSort(vector& nums,int low, int high){ if (low >= high) return; // 对 nums[low..high] 进行切分 // 使得 nums[low...p-1] 快速排序的核心就是将一个元素定好位，然后再将剩下的元素逐个定好。核心就是上面的 partition 函数，其作用是找到一个分界点，使得左边都小于分界点，右边都大于分界点 我们将快排用二叉树的方式展示出来，过程如下所示，最后形成的就是一棵二叉搜索树，所以快排的过程我们可以直接理解成构造一棵二叉搜索树的过程 同时，为了避免一些计算情况的出现，我们在 partition 中引入了 shuffling 操作 完整的快排代码实现如下所示 class QuickSort { public: vector sortArray(vector& nums) { shuffle(nums); QuickSort_helper(nums, 0, nums.size() - 1); return nums; } void QuickSort_helper(vector& nums,int low, int high){ if (low >= high) return; // 对 nums[low..high] 进行切分 // 使得 nums[low...p-1] & nums, int low, int high){ int pivot = nums[low]; // 关于区间的边界控制需要格外小心 // 我们这里定义为半开半闭区间 // [low, i) pivot int i = low + 1, j = high; // 当 i > j 时结束循环，以保证 [low, high] 全都被覆盖 while (i pivot while(j > low && nums[j] > pivot) j--; // 此时 while 结束恰好 nums[j] = j) break; swap(nums[i], nums[j]); } swap(nums[low], nums[j]); return j; } void shuffle(vector& nums){ int n = nums.size(); for (int i = 0;i 我们接下来分析下快排的时间复杂度吧，partition 执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组 nums[low..high] 的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数。 假设数组元素个数为 $N$，那么二叉树每一层的元素个数之和就是 $\\mathcal O(N)$；分界点分布均匀的理想情况下，树的层数为 $\\mathcal O(logN)$，所以理想的总时间复杂度为 $\\mathcal O(NlogN)$ 由于快速排序没有使用任何辅助数组，所以空间复杂度就是递归堆栈的深度，也就是树高 $\\mathcal O(logN)$ 快速排序的效率存在一定随机性，如果每次 partition 切分的结果都极不均匀，即数组已经是升序排列或降序排列，那么快速排序就退化成选择排序了，树高为 $\\mathcal O(N)$，每层节点的元素个数从 $N$ 开始递减，总的时间复杂度为： N+(N−1)+(N−2)+...+1=O(N2)\r N + (N - 1) + (N - 2) + ... + 1 = \\mathcal O(N^2)\r N+(N−1)+(N−2)+...+1=O(N​2​​) 所以我们说，快速排序理想情况的时间复杂度是 $\\mathcal O(NlogN)$，空间复杂度 $\\mathcal O(logN)$，极端情况下的最坏时间复杂度是 $\\mathcal O(N^2)$，空间复杂度是 $\\mathcal O(N)$ 还有一点需要注意的是，快速排序是「不稳定排序」，与之相对的，前文讲的归并排序 是「稳定排序」 如果单单排序 int 数组，那么稳定性没有什么意义。但如果排序一些结构比较复杂的数据，那么稳定性排序就有更大的优势了 比如说你有若干订单数据，已经按照订单号排好序了，现在你想对订单的交易日期再进行排序： 如果用稳定排序算法（比如归并排序），那么这些订单不仅按照交易日期排好了序，而且相同交易日期的订单的订单号依然是有序的 但如果你用不稳定排序算法（比如快速排序），那么虽然排序结果会按照交易日期排好序，但相同交易日期的订单的订单号会丧失有序性 在实际工程中我们经常会将一个复杂对象的某一个字段作为排序的 key，所以应该关注编程语言提供的 API 底层使用的到底是什么排序算法，是稳定的还是不稳定的，这很可能影响到代码执行的效率甚至正确性 【经典问题分析——215. 数组中的第K个最大元素】 题目描述 215. 数组中的第K个最大元素 解法 最常见的解法是大小堆，使用大小堆的时间复杂度是 $\\mathcal O(N\\log k)$，空间复杂度为 $\\mathcal O(k)$；而采用快排的话，时间复杂度就降为了 $\\mathcal O(N)$ 理由很简单：快排的时间复杂度也主要集中在 partition 函数上，我们需要估算 partition 函数执行了多少次，每次执行的时间复杂度是多少 最好情况下，每次 partition 函数切分出的 p 都恰好是正中间索引 (lo + hi) / 2（二分），且每次切分之后会到左边或者右边的子数组继续进行切分，那么 partition 函数执行的次数是 $\\log N$，每次输入的数组大小缩短一半 N+N/2+N/4+N/8+...+1=2N=O(N)\r N + N/2 + N/4 + N/8 + ... + 1 = 2N =\\mathcal O(N)\r N+N/2+N/4+N/8+...+1=2N=O(N) partition 函数也可能出现极端情况，最坏情况下 p 一直都是 lo + 1 或者一直都是 hi - 1，这样的话时间复杂度就退化为 O(N^2) 了： N+(N−1)+(N−2)+...+1=O(N2)\r N + (N - 1) + (N - 2) + ... + 1 =\\mathcal O(N^2)\r N+(N−1)+(N−2)+...+1=O(N​2​​) 这也是我们在代码中使用 shuffle 函数的原因，通过引入随机性来避免极端情况的出现，让算法的效率保持在比较高的水平。随机化之后的快速选择算法的复杂度可以认为是 $\\mathcal O(N)$ 讲完了为什么我们要用快排做这道题，下面看看代码实现吧，实现上非常类似于二分搜索的代码 class Solution { public: int findKthLargest(vector& nums, int k) { shuffle(nums); int low = 0, high = nums.size() - 1; k = nums.size() - k; while(low k) high = p - 1; else return nums[p]; } return -1; } int partition(vector& nums, int low, int high){ int pivot = nums[low]; // 关于区间的边界控制需要格外小心 // 我们这里定义为半开半闭区间 // [low, i) pivot int i = low + 1, j = high; // 当 i > j 时结束循环，以保证 [low, high] 全都被覆盖 while (i pivot while(j > low && nums[j] > pivot) j--; // 此时 while 结束恰好 nums[j] = j) break; swap(nums[i], nums[j]); } swap(nums[low], nums[j]); return j; } void shuffle(vector& nums){ int n = nums.size(); for (int i = 0;i "},"Part Two/动态规划.html":{"url":"Part Two/动态规划.html","title":"Part Two. 动态规划专栏","keywords":"","body":"1 动态规划初探 1.1 状态和转移方程 【核心思想】动态规划问题的一般形式就是求最值 为什么说动态规划一般形式就是求最值呢？ 这里给出一个概念『最优子结构』：如果问题的最优解包含的子问题的解也是最优的，就称该问题具有最优子结构，同时满足最优化原理 要符合『最优子结构』，子问题间必须相互独立 动态规划问题一定会具备『最优子结构』，因此就通过子问题的最值得到原问题的最值 【思维框架】 明确『状态』 -> 定义 dp 数组/函数的含义 -> 明确『选择』-> 明确 base case 但是，光光这么说还是会觉得很难定义出合适的状态和转移方程，使得递归正常地进行，毕竟不同的状态定义和状态转移方程都会使得解法的复杂度不同 所以，我们接从递归看起，我个人觉得下面例子真的是很好地从递归出发讲清楚了动态规划是什么 b（￣▽￣）d 1.2 从递归看动态规划 【经典问题分析——凑零钱】 题目描述 322. 零钱兑换 解法 1. 暴力递归 明确『状态』： 也就是原问题和子问题中变换的量，由于硬币数量无限，所以唯一的状态就是目标金额 $amount$ 定义 dp 函数的含义： 当前的目标金额是 $n$，至少需要 $dp(n)$ 个硬币凑出该金额 明确『选择』： 也就是对于每个状态，可以做出什么选择改变当前状态。具体到当前的问题上，无论当前的目标金额是多少，『选择』就是从面额列表 $coins$ 中选择一个硬币，然后目标金额就会减少 def coinChange(coins: List[int], amount: int): # 定义： 要凑出⾦额 n， ⾄少要 dp(n) 个硬币 def dp(n): # 做选择， 选择需要硬币最少的那个结果 for coin in coins: res = min(res, 1 + dp(n - coin)) return res # 我们要求的问题是 dp(amount) return dp(amount) 明确 base case： 显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1 def coinChange(coins: List[int], amount:int): def dp(n): # base case if n == 0: return 0 if n 至此，状态转移方程其实已经完成了 我们来看一下 $amount=11, coins=\\left {1, 2, 5\\right }$ 时的递归树 时间复杂度：子问题总数 × 每个子问题的时间 子问题总数为递归树中结点的个数，这个比较难看出来，是 $\\mathcal O(n^k)$；每个子问题中含有一个 for 循环，复杂度为 $\\mathcal O(k)$，故暴力递归下的总时间复杂度为 $\\mathcal O(k\\times n^k)$ 2. 带备忘录的递归 def coinChange(coin, amount): # 备忘录 memo = dict() def dp(n): # 查备忘录，避免重复计算 if n in memo: return memo[n] if n == 0: return 0 if n 很显然 『备忘录』大大减小了子问题数目，完全消除了子问题冗余的问题，所以子问题总数不会超过金额数 $n$，即子问题复杂度为 $\\mathcal O(n)$，处理一个子问题的时间不变，仍是 $\\mathcal O(k)$，所以总时间复杂度为 $\\mathcal O(kn)$ 3. dp 数组的迭代解法 在上面添加备忘录的代码中已经很接近 dp 的思想了，下面我们看一下 dp 数组的完整解法 $dp[i] = x\\ 表示当目标金额为\\ i\\ 时，\\ 至少需要\\ x\\ 枚硬币$ def coinChange(coins, amount): dp = [amount + 1] * (amount + 1) dp[0] = 0 for i in range(len(dp)): for coin in coins: if i - coin 2 背包问题 2.1 0-1背包、满包 有 $N$ 件物品和一个容量为 $V$ 的背包。放入第 $i$ 件物品耗费的空间是 $C_i$，得到的价值是 $W_i$，求解将哪些物品装入背包可使价值总和最大 基本思路 $f(i, j)$ 表示前 $i$ 件物品放入一个容量为 $j$ 的背包可以获得的最大价值 于是，转移方程可以表述为 f(i,j)=max(f(i−1,j),f(i−1,j−wi)+vi)f(i,j) = max(f(i-1, j), f(i-1,j-w_i)+v_i)f(i,j)=max(f(i−1,j),f(i−1,j−w​i​​)+v​i​​) //二维 for(int i=1;i=volume[i]) dp[i][j] = max(dp[i-1][j], m[i-1][j-volume[i]]+value[i]); else dp[i][j] = dp[i-1][j]; } } 优化空间复杂度 // 一维 for(int i=1;i=volume[i];j--) dp[j] = max(dp[j], dp[j-volume[i]]+value[i]); } 满包 满背包与普通背包唯一不同的点就是恰好装满背包所能取得的最大价值，主要区别在于初始化，满包问题的初始条件：$f(1...v)=-\\infty,\\ f(0)=0$ 可以这样理解： $f[...]$ 的初始化状态表示的是没有任何物品可以放入背包时的合法状态，如果要求背包恰好装满，那么初始化 $f(1...v)=0$ 就不对了，因为此时表示恰好装满容量为 $v$ 的背包时物品价值为 0，所以在满包问题中初始化条件为 $f(1...v)=-\\infty,\\ f(0)=0$ 洛谷 P2925 - Hay For Sale S 洛谷 P1164 - 小A点菜 HDU 3466 - Proud Merchants 2.2 完全背包 有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。放入第 $i$ 种物品的耗费的空间是 $C_i$，得到的价值是 $W_i$ 求解：将哪些物品装入背包，可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 for(int i=1;i 这个代码与 0-1 背包的代码只有 $j$ 的循环次序不同而已。为什么这样一改就可行呢？ 首先，想想为什么 0-1 背包中要按照 $j=V...0$ 的逆序来循环？这是因为要保证第 $i$ 次循环中的状态 $f[i][j]$ 是由状态 $f[i−1][j−w[i]]$ 递推而来。换句话说，这正是为了保证每件物品只选一次，在考虑 “ 选入第 $i$ 件物品 ” 时的策略，是依据一个没有选入第 $i$ 件物品的子结果 $f[i−1][j−w[i]]$ 而现在完全背包的特点恰是每种物品可选无限件，所以在考虑 “ 加选一件第 $i$ 种物品 ” 时，却正需要一个可能已选入第 $i$ 种物品的子结果 $f[i][j−w[i]]$，所以就可以并且必须采用$j=0...V$的顺序循环。这就是这个简单的程序为何成立的道理 洛谷 P1616 - 疯狂的采药 HDU 1114 - Piggy-Bank 洛谷 P1853 - 投资的最大效益 LeetCode 面试题 08.11 - 硬币 2.1.3 多重背包 给n种物品和一个容量为v的背包,每种物品最多有num[i]件可用,每个物品都有一个体积volume[i]和价值value[i],求背包最多能装多少价值的物品? 二进制优化 把第$i$种物品换成$p[i]$件0-1背包中的物品，则得到了物品数为$\\sum_i p[i]$的01背包问题，直接求解，复杂度仍然是$O(V*\\sum_i p[i])$。 但是我们期望将它转化为0-1背包问题之后能够像完全背包一样降低复杂度。 仍然考虑二进制的思想，我们考虑把第$i$种物品换成若干件物品，使得原问题中第$i$种物品可取的每种策略——取$0...p[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$p[i]$件的策略必不能出现。 具体方法是：将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为$1,2,4,...,2k−1,p[i]-2^k+1$且$k$是满足$p[i]−2^k+1>0$的最大整数。 例如，如果$p[i]$为13，就将这种物品分成系数分别为1,2,4,6的四件物品。分成的这几件物品的系数和为$p[i]$，表明不可能取多于$p[i]$件的第$i$种物品。另外这种方法也能保证对于$0...p[i]$间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0...2^{k}-1$和$2^{k}...p[i]$两段来分别讨论得出，并不难。这样就将第$i$种物品分成了$O(log(p[i]))$种物品，将原问题转化为了复杂度为$O(V∗\\sum_i log(p[i]))$的0-1背包问题，是很大的二进制优化 int count = 0, vval[M], vol[M]; // count存分解后的物品总数 //vval存分解后的每件物品的价值 //vvol存分解完成后每件物品的代价 //二进制分解 for(int i=1;i0) { vval[count] = num[i]*val[i]; vol[count] = num[i]*vol[i]; count++; } } // 0-1背包问题 memset(dp, 0, sizeof(dp)) ; for(int i=1;i=vol[i];j--) dp[j] = max(dp[j], dp[j-vol[i]]+val[i]); 简化版本 int dp[M] = {}; for(int i=1;i=k*vol;--j) dp[j] = max(dp[j], dp[j-k*vol]+k*val); for(int j=v;j>=num*vol;--j) dp[j] = max(dp[j], dp[j-num*vol]+num*val); } 单调队列优化 多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。 int dp[M]; for(int i=1;i=b[r-1]) tail--; // 出队 a[tail] = j; b[tail++] = y; while(a[head] 这里，应先确保搞明白了单调队列，就是在区间移动时动态维护区间的最值 观察多重背包的转移方程： $f[i][j]=max(f[i−1][j],f[i−1][j−k∗vol[i]]+k∗val[i])$ 单调队列优化的主要思想就是分组更新，因为$vol[i]$是成倍增加的$f[i−1][j]$只会更新$f[i−1][j+k∗w[i]]$（这里是从前往后看的，所以是+）。对于当前$vol$的体积，我们可以按照余数将它分为$vol$组，也就是$0...vol−1$. 并且，同一个剩余系的数在一组,比如在模3意义下，1,4,7,10是一组，2,5,8,11是一组，3,6,9,12是一组每组的转移是互不影响的，也就是单独转移 举个例子 $f[i][5vol] = max(f[i-1][4vol]+val, f[i-1][3vol]+2val, f[i-1][2vol]+3val, f[i-1][vol]+val, f[i-1][0]+5val)$ $f[i][4vol] = max(f[i-1][3vol]+val, f[i-1][2vol]+2val, f[i-1][vol]+3val, f[i-1][vol]+val, f[i-1][0]+4val)$ 让所有$f[i][j]$都减去$j/vol*val$ $f[i][5vol] = max(f[i-1][4vol]-4val, f[i-1][3vol]-3vol, f[i-1][2vol]-2val, f[i-1][vol]-val, f[i-1][0])$ $f[i][4vol] = max(f[i-1][3vol]-3val, f[i-1][2vol]+2val, f[i-1][vol]-2val, f[i-1][vol]-val, f[i-1][0])$ 即$f[i][j]=max(f[i−1][j \\ mod\\ vol+k∗vol]−k∗val+j∗val)$ 当$j\\ mod\\ w$一定后，就可以用单调队列来优化了 HDU 1059 - Dividing 洛谷 - P1776 宝物筛选 2.1.4 混合背包 顾名思义，混合背包就是有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包） 最直接的想法：二进制分解。可以取无限次物品我们就记其num=99999，这样同样可以利用二进制分解开来 void binary_split() { for(int i=1;i=ccost[i];j--) dp[j] = max(dp[j], dp[j-ccost[i]]+vvalue[i]); 洛谷 P1833 - 樱花 2.1.5 二维费用背包 给一个容量为V的背包,你的负重最大只有W,然后有n种物品,每种都有若干个(0个,无限,多个),体积为volume[i],重量为weight[i],价值为value[i].问最多能装多少价值的物品,在不超过体积及负重的情况下? for(int i=1;i=volume[i];j--) for(int k=w;k>=weight[i];k--) dp[j][k]=max(dp[j][k],dp[j-volume[i]][k-weight[i]]+value[i]); 洛谷 P1507 - NASA的食物计划 HDU 2159 - FATE 2.1.7 分组背包 有n件物品可以被放入一个容量为v的背包中,每件物品体积为volume[i],价值为value[i].此外,这些物品被分成p组,每组中的物品最多只能选一件,求背包中最多可以装多少价值的物品. for(int k=1;k=0;j–) //此处遍历顺序与物品种类有关 for(int i: part[k]) dp[j]=max(dp[j],dp[j-volume[i]]+value[i]). 注意遍历方式一定是$kji$,如果是$kij$的话就无法保证每组只选一个了。 先$j$再$i$保证了每组内,每个体积只会被一个最优的物品访问到。 洛谷 P1757 - 通天之分组背包 HDU 1712 - ACboy needs your help 2.1.8 有依赖的背包问题 这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品i依赖于 物品j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物 品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多 件物品。 for(int i=1;i=volume[k];j--) tmp[j]=max(tmp[j],tmp[j-volume[k]]+value[k]); for(int j=v;j>=volume[i];j--) dp[j]=max(dp[j],tmp[j-volume[i]]+value[i]); } 洛谷 P1064 - 金明的预算方案 HDU 3449 - Consumer2.1.9 泛化物品 泛化物品准确来说,不是一类题目，而是一种思想。泛化物品的定义是 考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分 配给它的费用而变化。这就是泛化物品的概念。 or 更严格的定义之。在背包容量为V 的背包问题中，泛化物品是一个定义 域为0 . . . V 中的整数的函数h，当分配给它的费用为v时，能得到的价值就 是h(v)。 or 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0 . . . V ]， 给它费用v，可得到价值h[v]。 于是， 一个0-1背包中的物品(体积$ci$,价值$wi$),它的泛化物品模型是$h(ci)=wi$，$h(其他)=0$ 一个完全背包中的物品,它的模型是$h(cik)=wik$,其中k为正整数且$ci*k 一个多重背包中的物品,则是$h(cik)=wik$，其中$k 一个互斥的物品组，$h(ci)=wi$，$i$取遍组中物品的编号，$ci$相同时$wi$取最小值，$h(其他)=0$ 泛化物品的和 如果给定两个泛化物品$a$和$b$，现在有体积v来装这两种物品，要求获得最大价值，怎么做? 则$dp[j]=max(a(k)+b(v-k))$，$k$取遍$0$到$j$，答案就是$dp[v]$ 新合成的dp数组，实际上，也是一个泛化物品。 由泛化物品的性质可知，如果将两个泛化物品这样合成一个新的物品，新的物品在问题中完全可以取代原有的两个物品。 2.1.10 背包问题问法的变化 记录具体的选择 如果需要记录具体的选择，可以另起一个 x[ ] 数组，x[i]=0表示不拿，x[i]=1表示拿。 f[n][c]为最优值，如果f[n][c]=f[n-1][c] ,说明有没有第n件物品都一样，则x[n]=0 ; 否则 x[n]=1。当x[n]=0时，由x[n-1][c]继续构造最优解；当x[n]=1时，则由x[n-1][c-w[i]]继续构造最优解。以此类推，可构造出所有的最优解。 for(int i=n;i>1;i--) { if(dp[i][v]==dp[i-1][v]) x[i] = 0; else { x[i] = 1; v -= volume[i]; } x[1] = (dp[1][c]>0)?1:0; } 输出字典序最小的方案 字典序最小是指$N$号物品的选择方案排列出来以后字典序最小 我们的做法是：先把物品逆序排列一下，然后按照前面的状态转移方程来求值。唯一要注意的是，如果$f[i][j]==f[i−1][i−j]f[i][j]$以及$f[i][j]==f[i−1][j−w[i]]+v[i]$同时成立，应该按照后者（即选择了物品$i$）输出 求方案总数 当我们要求装满背包或者将背包装至某一指定容量的方案总数时，一般只需要将转移方程的max改成sum即可。初始条件为$dp[0][0]=1$ 求最优方案的总数 这里与求方案总数不同的是我们要求所装的物品价值最大，于是，结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：$f[i][j]$意义同前述，$g[i][j]$表示这个子问题的最优方案的总数，则在求$f[i][j]$的同时求$g[i][j]$ 求次优解，第K优解 求次优解往往可以相同的复杂度解决，第K优解则比求最优解的复杂度上多一个系数K。其基本思想是将每个状态都表示成有序队列，将状态转移方程中的max/min转化成有序队列的合并。 这里只讲一下0-1背包的情况： 如果要求第K优解，那么状态$f[i][j]$就应该是一个大小为K的数组$f[i][j][1...K]$。其中$f[i][j][k]$表示前i个物品、背包大小为j时，第k优解的值。“$f[i][j]$是一个大小为K的数组”这一句，熟悉C语言的同学可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然$f[i][j][1...K]$这K个数是由大到小排列的，所以我们把它认为是一个有序队列。然后原方程就可以解释为：$f[i][j]$这个有序队列是由$f[i−1][j]$和$f[i−1][j−w[i]]+v[i]$这两个有序队列合并得到的。有序队列f[i−1][j]f[i-1][j]f[i−1][j]即$f[i−1][j][1...K]$，$f[i−1][j−w[i]]+v[i]$则理解为在$f[i−1][j−w[i]][1...K]$的每个数上加上$v[i]$后得到的有序队列。合并这两个有序队列并将结果的前KKK项储存到$f[i][j][1...K]$中的复杂度是$O(K)$。最后的答案是$f[N][V][K]$。总的复杂度是$O(VNK)$。为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为KKK的数组，并在这个数组中有序的保存该状态可取到的前KKK个最优值。那么，对于任两个状态的max运算等价于两个由大到小的有序队列的合并。 HDU 2639 - Bone Collector II 3 股票问题 我们先来推一个范式，问题描述如下 动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解 所以，我们先在这道题中确定出所有的「状态」和「选择」 每天都有三种「选择」：买入、卖出、无操作，我们用 buy，sell，rest 表示这三种选择 「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的rest的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。而 我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，手上的股票都卖出，最多获得多少利润 接着，我们确定一下状态转移 很容易看出，状态转移方程 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 今天选择 rest, 今天选择 sell ) 需要注意 k 的限制，在选择 buy 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 k 应该减小 1 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 今天选择 rest, 今天选择 buy ) 最后，我们确定一下 base dp[-1][...][0] = 0 // 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。 dp[-1][...][1] = -infinity // 解释：还没开始的时候，是不可能持有股票的。 // 因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。 dp[...][0][0] = 0 // 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。 dp[...][0][1] = -infinity // 解释：不允许交易的情况下，是不可能持有股票的。 // 因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。 【经典问题分析——买卖股票的最佳时机】 题目描述 121. 买卖股票的最佳时机 解法 这道题相当于 k=1，我们确定一下这道题的状态转移方程和 base case dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) // 解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。 // 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。 // 可以进行进一步化简去掉所有 k： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) 于是，我们可以直接写出代码 int n = prices.size; vector> dp(n, vector(2, 0)); for (int i = 0; i 显然 i = 0 时 i - 1 是不合法的索引，这是因为我们没有对 i 的 base case 进行处理，可以这样给一个特化处理 if (i - 1 == -1) { dp[i][0] = 0; // 根据状态转移方程可得： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; // 根据状态转移方程可得： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; } 完整的代码如下所示，但是我们仔细观察可以发现在状态转移方程中，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 $O(1)$ // 原始版本 class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); vector> dp(n, vector(2, 0)); for (int i = 0; i & prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i 【经典问题分析——买卖股票的最佳时机 II】 题目描述 122. 买卖股票的最佳时机 II 解法 这道题相当于 k=+infinity，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 完整代码如下所示 class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i 【经典问题分析——最佳买卖股票时机含冷冻期】 题目描述 309. 最佳买卖股票时机含冷冻期 解法 在 k=+infinity 的基础上，加上了冷冻期，也就是每次 sell 之后要等一天才能继续交易 我们可以将这个特点 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]) // 解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。 完整代码如下所示 // 原始版本 class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); vector> dp(n, vector(2, 0)); for (int i = 0; i & prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; int dp_pre_0 = 0; for (int i = 0; i 【经典问题分析——买卖股票的最佳时机含手续费】 题目描述 714. 买卖股票的最佳时机含手续费 解法 在 k=+infinity 的基础上，加上手续费，那么每次交易要支付手续费，只要把手续费从利润中减去即可 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee) // 解释：相当于买入股票的价格升高了。 // 在第一个式子里减也是一样的，相当于卖出股票的价格减小了。 完整代码如下所示 // 原始版本 class Solution { public: int maxProfit(vector& prices, int fee) { int n = prices.size(); vector> dp(n, vector(2, 0)); for (int i = 0; i & prices, int fee) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i 【经典问题分析——买卖股票的最佳时机 III】 题目描述 123. 买卖股票的最佳时机 III 解法 我们先看一下没有空间优化的代码，有两点是明显的不同，都是关于 k 的： 我们前面说到动态规划的核心是穷举所有状态，这里明显 k 出现了多种选择（k=2），所以也要对 k 进行一次循环遍历完所有的状态 其次，在关于 k 循环时，我们选择 k-- 的方式。实际上 dp[i][k] 不会依赖 dp[i][k - 1]，而是依赖 dp[i - 1][k - 1]，对于 dp[i - 1][...]，都是已经计算出来的。所以不管你是 k = max_k, k--，还是 k = 1, k++，都是可以得出正确答案的。但是，我们买股票的初始的「状态」应该是从第 0 天开始，而且还没有进行过买卖，所以最大交易次数限制 k 应该是 max_k；而随着「状态」的推移，你会进行交易，那么交易次数上限 k 应该不断减少，这样一想，k = max_k, k-- 的方式是比较合乎实际场景的 // 原始版本 class Solution { public: int maxProfit(vector& prices) { int max_k = 2, n = prices.size(); int dp[n][max_k + 1][2]; memset(dp, 0, sizeof(dp)); for (int i = 0; i = 1; k--) { if (i - 1 == -1) { dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; } dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]); dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]); } } return dp[n - 1][max_k][0]; } }; // 空间优化版本 class Solution { public: int maxProfit(vector& prices) { int dp_i10 = 0, dp_i11 = INT_MIN; int dp_i20 = 0, dp_i21 = INT_MIN; for (int price: prices) { // 状态转移方程： // dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]) // dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]) // dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) // dp[i][1][1] = max(dp[i-1][1][1], -prices[i]) dp_i20 = max(dp_i20, dp_i21 + price); dp_i21 = max(dp_i21, dp_i10 - price); dp_i10 = max(dp_i10, dp_i11 + price); dp_i11 = max(dp_i11, -price); } return dp_i20; } }; 【经典问题分析——买卖股票的最佳时机 IV】 题目描述 188. 买卖股票的最佳时机 IV 解法 这里有个小技巧，防止直接套用上题代码会超内存：一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity class Solution { public: int maxProfit(int k, vector& prices) { int max_k = k, n = prices.size(); if (n == 0) return 0; if (max_k > n / 2) return max_k_inf(prices); // base case： // dp[-1][...][0] = dp[...][0][0] = 0 // dp[-1][...][1] = dp[...][0][1] = -infinity int dp[n][max_k + 1][2]; // k = 0 时的 base case for (int i = 0; i = 1; k--) { if (i - 1 == -1) { // 处理 i = -1 时的 base case dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; } dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]); dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]); } } return dp[n - 1][max_k][0]; } int max_k_inf(vector& prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; int dp_pre_0 = 0; for (int i = 0; i 4 House Robber 【经典问题分析——打家劫舍】 题目描述 198. 打家劫舍 解法 这道题也是一个很典型的 DP 问题，「状态」和「选择」也很明确：你面前房子的索引就是状态，抢和不抢就是选择 同样的这里在对于同一 start 位置，是存在重叠子问题的，所以我们可以用备忘录优化 那么自顶向下的解法就可描述为 private int[] memo; // 主函数 public int rob(int[] nums) { // 初始化备忘录 memo = new int[nums.length]; Arrays.fill(memo, -1); // 强盗从第 0 间房子开始抢劫 return dp(nums, 0); } // 返回 dp[start..] 能抢到的最大值 private int dp(int[] nums, int start) { if (start >= nums.length) { return 0; } // 避免重复计算 if (memo[start] != -1) return memo[start]; int res = Math.max(dp(nums, start + 1), nums[start] + dp(nums, start + 2)); // 记入备忘录 memo[start] = res; return res; } 我们把它改为自底向上的解法 int rob(int[] nums) { int n = nums.length; // dp[i] = x 表示： // 从第 i 间房子开始抢劫，最多能抢到的钱为 x // base case: dp[n] = 0 int[] dp = new int[n + 2]; for (int i = n - 1; i >= 0; i--) { dp[i] = Math.max(dp[i + 1], nums[i] + dp[i + 2]); } return dp[0]; } 同样的，我们做一个空间复杂度优化，最终的结果就是 class Solution { public: int rob(vector& nums) { int n = nums.size(); int dp_i_1 = 0, dp_i_2 = 0, dp_i = 0; for (int i = n -1; i >= 0; i--) { dp_i = max(dp_i_1, nums[i] + dp_i_2); dp_i_2 = dp_i_1; dp_i_1 = dp_i; } return dp_i; } }; 【经典问题分析——打家劫舍 II】 题目描述 213. 打家劫舍 II 解法 在上道题的情况下，我们这里将房子排成了一个圈，相当于第一间房子和最后一间房子也相当于是相邻的，不能同时抢。那么我们这里分三种情况来看看：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢 很显然，情况一无论如何都可能比情况二、三小，因为它能选择的范围都要比情况二、三少一个，所以我们不研究情况一 那么事情就好办多了，我们按照情况二走一遍 DP，按照情况三走一遍 DP，取两者最大的结果即可 class Solution { public: int rob(vector& nums) { int n = nums.size(); if (n == 1) return nums[0]; return max(dp(nums, 0, n - 2), dp(nums, 1, n - 1)); } int dp(vector& nums, int start, int end) { int n = nums.size(); int dp_i_1 = 0, dp_i_2 = 0, dp_i = 0; for (int i = end; i >= start; i--) { dp_i = max(dp_i_1, nums[i] + dp_i_2); dp_i_2 = dp_i_1; dp_i_1 = dp_i; } return dp_i; } }; 【经典问题分析——打家劫舍 III】 题目描述 337. 打家劫舍 III 解法 现在我们的房屋不是一排，也不是环状了，我们的房屋是一棵二叉树，道理还是一样的，这里我们按照自顶向下的方法用递归去做吧 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map memo; int rob(TreeNode* root) { if (root == nullptr) return 0; if (memo.find(root) != memo.end()) return memo[root]; // 抢 int do_it = root->val + (root->left == nullptr ? 0 : rob(root->left->left) + rob(root->left->right)) + (root->right == nullptr? 0 : rob(root->right->left) + rob(root->right->right)); // 不抢 int not_do = rob(root->left) + rob(root->right); int res = max(do_it, not_do); memo[root] = res; return res; } }; 同样，我们还是尝试优化下备忘录，不使用额外的备忘录，虽然不会改变算法的时间复杂度（$\\mathcal O(N)$），但是减少了一定的数据操作复杂性，在实际运行上效率会更快一些 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int rob(TreeNode* root) { vector res = dp(root); return max(res[0], res[1]); } /* 返回一个大小为 2 的数组 arr arr[0] 表示不抢 root 的话，得到的最大钱数 arr[1] 表示抢 root 的话，得到的最大钱数 */ vector dp(TreeNode* root) { if (root == nullptr) return {0, 0}; vector left = dp(root->left); vector right = dp(root->right); int rob = root->val + left[0] + right[0]; int not_rob = max(left[0], left[1]) + max(right[0], right[1]); return {not_rob, rob}; } }; "},"Part Three/1数组.html":{"url":"Part Three/1数组.html","title":"1 数组","keywords":"","body":"1 数组 二维数组转转转 【经典问题】旋转图像 题目描述 48. 旋转图像 解法 有时候咱们拍脑袋的常规思维，在计算机看来可能并不是最优雅的；但是计算机觉得最优雅的思维，对咱们来说却不那么直观 所以这道题的计算机流程应该是这样的，先按照左上到右下的对角线进行镜像对称，然后翻转每一行 class Solution { public: void rotate(vector>& matrix) { int n = matrix.size(); for (int i = 0; i & nums){ int i = 0, j = nums.size() - 1; while (j > i){ swap(nums[i], nums[j]); i++; j--; } } }; 发散一下，既然会了顺时针旋转 90 度，那逆时针呢？ 思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果 class Solution { public: void rotate(vector>& matrix) { int n = matrix.size(); for (int i = 0; i & nums){ int i = 0, j = nums.size() - 1; while (j > i){ swap(nums[i], nums[j]); i++; j--; } } }; 【经典问题】螺旋矩阵 题目描述 54. 螺旋矩阵 解法 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界： 随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组： class Solution { public: vector spiralOrder(vector>& matrix) { int m = matrix.size(), n = matrix[0].size(); int upper_bound = 0, lower_bound = m - 1; int left_bound = 0, right_bound = n - 1; vector res; while ( res.size() = left_bound; j--){ res.push_back(matrix[lower_bound][j]); } lower_bound--; } if (left_bound = upper_bound; i--){ res.push_back(matrix[i][left_bound]); } left_bound++; } } return res; } }; 【经典问题】螺旋矩阵 II 题目描述 59. 螺旋矩阵 II 解法 和上面一样，不过我们在转圈的时候将数字填入矩阵 class Solution { public: vector> generateMatrix(int n) { int upper_bound = 0, lower_bound = n - 1; int left_bound = 0, right_bound = n - 1; vector> matrix(n, vector(n)); int num = 1; while ( num = left_bound; j--){ matrix[lower_bound][j] = num++; } lower_bound--; } if (left_bound = upper_bound; i--){ matrix[i][left_bound] = num++; } left_bound++; } } return matrix; } }; "},"Part Three/2链表.html":{"url":"Part Three/2链表.html","title":"2 链表","keywords":"","body":"2 链表 链表是个老生常谈的问题，这里我们做一个小结。关于链表还有一部分内容是在指针那一块 【经典问题分析——合并两个有序链表】 题目描述 21. 合并两个有序链表 解法 解法有递归和迭代两种，这里我们介绍迭代，还有一种递归的方法应该很容易想到，可以参考 LeetCode 21 - 合并两个有序链表 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode newhead(0); ListNode* p = &newhead; while (list1 != nullptr && list2 != nullptr) { if (list1->val > list2->val) { p->next = list2; list2 = list2->next; } else { p->next = list1; list1 = list1->next; } p = p->next; } p->next = list1 ? list1 : list2; return newhead.next; } }; 【经典问题分析——合并K个有序链表】 题目描述 23. 合并K个升序链表 解法 这里会用到一个数据结构叫做优先级队列，也就是二叉堆，关于二叉堆我们不需要自己手动从底层实现，调用下 C++ STL 中的 priority_queue 关于这道题还有一种分治的解法，可以参考 LeetCode 23 - 合并k个排序链表 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: struct cmp{ bool operator()(ListNode* a, ListNode* b) { return a->val > b->val; } }; ListNode* mergeKLists(vector& lists) { priority_queue, cmp> heapk; for (auto p: lists) if (p != nullptr) heapk.push(p); ListNode* phead = new ListNode(-1); ListNode* pcur = phead; while (!heapk.empty()) { ListNode* top = heapk.top(); heapk.pop(); pcur->next = top; pcur = pcur->next; if (top->next!=nullptr) heapk.push(top->next); } return phead->next; } }; 弹出操作时，比较操作的代价会被优化到 $\\mathcal O(\\log k)$。同时，找到最小值节点的时间开销仅仅为 $\\mathcal O(1)$ "},"Part Three/3树.html":{"url":"Part Three/3树.html","title":"3 树","keywords":"","body":"3 树 二叉树——构造 【经典问题】从前序与中序遍历序列构造二叉树 问题描述 105. 从前序与中序遍历序列构造二叉树 解法 2 ——迭代 迭代的算法流程： 我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子 无论是哪一种情况，我们最后都将当前的节点入栈 看下面流程图是分清楚，入栈的过程就是在构建左子树，而出栈的过程就是回溯，找到合适的右孩子插入位置 这样做的依据是： 对于前序遍历中的任意两个连续节点 $u$ 和 $v$，根据前序遍历的流程，我们可以知道 $u$ 和 $v$ 只有两种可能的关系： $v$ 是 $u$ 的左儿子。这是因为在遍历到 $u$ 之后，下一个遍历的节点就是 $u$ 的左儿子，即 $v$； $u$ 没有左儿子，并且 $v$ 是 $u$ 的某个祖先节点（或者 $u$ 本身）的右儿子。如果 $u$ 没有左儿子，那么下一个遍历的节点就是 $u$ 的右儿子。如果 $u$ 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 $u$ 不在它的右儿子的子树中）的节点 $u_a$ ，那么 $v$ 就是 $u_a$ 的右儿子 简单来说，$v$ 要是 $u$ 的左儿子，在中序遍历中 $v$ 比出现在 $u$ 的左边 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector& preorder, vector& inorder) { if (!preorder.size()) { return nullptr; } TreeNode* root = new TreeNode(preorder[0]); stack st; st.push(root); int inorderIndex = 0; for (int i = 1; i val != inorder[inorderIndex]){ node->left = new TreeNode(preorderVal); st.push(node->left); } else{ while (!st.empty() && st.top()->val == inorder[inorderIndex]){ node = st.top(); st.pop(); ++inorderIndex; } node->right = new TreeNode(preorderVal); st.push(node->right); } } return root; } }; 二叉搜索树——特性 我们知道二叉搜索树最大的特点就是中序遍历的结果即是一个升序排序的结果 【经典问题分析——二叉搜索树中第K小的元素】 题目描述 230. 二叉搜索树中第K小的元素 解法： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int res = 0, rank = 0; int kthSmallest(TreeNode* root, int k){ traverse(root, k); return res; } void traverse(TreeNode* root, int k){ if (root == nullptr) return; traverse(root->left, k); rank++; if (k == rank) res = root->val; traverse(root->right, k); } }; 我们考虑一个情景，如果按照上面的做法，每次寻找第 k 小的元素就要进行一次中序遍历，最坏的时间复杂度是 $\\mathcal O(N)$，要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是$\\mathcal O(\\log N)$ 的复杂度，让你算一个第 k 小元素，时间复杂度竟然要 $\\mathcal O(N)$，有点低效了 有没有办法改进一下呢？有，记录子树的结点数即可 想找到第 k 小的元素，或者说找到排名为 k 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几 比如说你让我查找排名为 k 的元素，当前节点知道自己排名第 m，那么我可以比较 m 和 k 的大小： 如果 m == k ，显然就是找到了第 k 个元素，返回当前节点就行了 如果 k 如果 k > m，那说明排名第 k 的元素在右子树，所以可以去右子树搜索第 k - m - 1 个元素 这样就可以将时间复杂度降到 $\\mathcal O(\\log N)$ 了 那么，如何让每一个节点知道自己的排名呢？ 这就是我们之前说的，需要在二叉树节点中维护额外信息。每个节点需要记录，以自己为根的这棵二叉树有多少个节点 也就是说，我们 TreeNode 中的字段应该如下： class TreeNode { int val; // 以该节点为根的树的节点总数 int size; TreeNode left; TreeNode right; } 具体如何实现上面说的算法呢，在不能重新定义 TreeNode 的情况下？如下所示，用一个 map 来存储节点和子树的节点数即可 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class MyBST{ public: MyBST(TreeNode* root){ this->root = root; countNodeNum(root); } int kthSmallest(int k){ TreeNode* node = root; while (node != nullptr) { int left = getNodeNum(node->left); if (left right; k -= left + 1; } else if (left == k - 1) break; else node = node->left; } return node->val; } private: TreeNode* root; unordered_map nodeNum; int countNodeNum(TreeNode* node){ if (node == nullptr) return 0; nodeNum[node] = 1 + countNodeNum(node->left) + countNodeNum(node->right); return nodeNum[node]; } int getNodeNum(TreeNode* node){ if (node != nullptr && nodeNum.count(node)) return nodeNum[node]; else return 0; } }; class Solution { public: int kthSmallest(TreeNode* root, int k) { MyBST bst(root); return bst.kthSmallest(k); } }; 3.2 二叉搜索树——构造 在这一节我们将探讨如何实现 BST 的基本操作：判断 BST 的合法性、增、删、查 判断 BST 的合法性 一个易犯的错是只比较结点和它的左右孩子，正确的操作是比较结点和它的整个左右子树，代码实现如下 bool isValidBST(TreeNode* root) { return helper(root, nullptr, nullptr); } /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */ bool helper(TreeNode* root, TreeNode* min, TreeNode* max) { // base case if (root == nullptr) return true; // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST if (min != nullptr && root.val = max.val) return false; // 限定左子树的最大值是 root.val，右子树的最小值是 root.val return isValidBST(root->left, min, root) && isValidBST(root->right, root, max); } 对应 LeetCode 的题目是 98. 验证二叉搜索树，因为比较简单就不再详细列出 在 BST 中搜索一个数 在 BST 中搜索一个数，用不到遍历整棵树，用二分的思想就可以 bool isInBST(TreeNode* root, int target) { if (root == nullptr) return false; if (root->val == target) return true; if (root->val right, target); if (root->val > target) return isInBST(root->left, target); } 对应 LeetCode 的题目是 700. 二叉搜索树中的搜索 在 BST 中插入一个数 插入一个数即在 BST 中先找到其对应的位置，在空指针处插入即可 TreeNode* insertIntoBST(TreeNode* root, int val) { // 找到空位置插入新节点 if (root == nullptr) { TreeNode* node = new TreeNode(val); return node; } // if (root.val == val) // BST 中一般不会插入已存在元素 if (root->val right = insertIntoBST(root->right, val); if (root->val > val) root->left = insertIntoBST(root->left, val); return root; } 对应 LeetCode 的题目是 701. 二叉搜索树中的插入操作 在 BST 中删除一个数 删除有点稍微复杂，我们分情况讨论一下 情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以直接删除 if (root->left == nullptr && root->right == nullptr) return nullptr; 情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置 // 排除了情况 1 之后 if (root->left == null) return root->right; if (root->right == null) return root->left; 情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己 我们取后一种情况来说明 if (root->left != null && root->right != null) { // 找到右子树的最小节点 TreeNode* minNode = getMin(root->right); // 把 root 改成 minNode root->val = minNode->val; // 转而去删除 minNode root->right = deleteNode(root->right, minNode->val); } 完整的删除代码如下所示 TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return nullptr; if (root->val == key) { // 这两个 if 把情况 1 和 2 都正确处理了 if (root->left == nullptr) return root->right; if (root->right == nullptr) return root->left; // 处理情况 3 TreeNode* minNode = getMin(root->right); root->val = minNode->val; root->right = deleteNode(root->right, minNode->val); } else if (root->val > key) { root->left = deleteNode(root->left, key); } else if (root->val right = deleteNode(root->right, key); } return root; } TreeNode* getMin(TreeNode* node) { // BST 最左边的就是最小的 while (node->left != nullptr) node = node->left; return node; } 注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会是一个复杂的数据结构，修改起来非常麻烦；而链表操作无非改一改指针，而不会去碰内部数据 对应 LeetCode 的题目是 450. 删除二叉搜索树中的节点 3.3 完全二叉树和满二叉树 二叉树里面有两个特例，一个是满二叉树，一个是完全二叉树。如果要计算满满二叉树的节点数，其实很简单，根据节点总数和树的高度的指数关系既可以得到。那么完全二叉树呢？遍历一棵二叉树的时间复杂度是 $\\mathcal O(N)$，有没有更高效一点的方法呢？有，且时间复杂度为 $\\mathcal O(\\log N * \\log N)$，具体代码如下所示 int countNodes(TreeNode* root) { TreeNode* l = root; TreeNode* r = root; // 记录左、右子树的高度 int hl = 0, hr = 0; while (l != nullptr) { l = l->left; hl++; } while (r != nullptr) { r = r->right; hr++; } // 如果左右子树的高度相同，则是一棵满二叉树 if (hl == hr) { return int(pow(2, hl) - 1); } // 如果左右高度不同，则按照普通二叉树的逻辑计算 return 1 + countNodes(root->left) + countNodes(root->right); } 我们直觉感觉好像最坏情况下是 $\\mathcal O(N*\\log N)$ 吧，因为之前的 while 需要 $\\log N$ 的时间，最后要 $\\mathcal O(N)$ 的时间向左右子树递归 return 1 + countNodes(root->left) + countNodes(root->right); 但事实上，这两个递归只有一个会真的递归下去，另一个一定会触发 hl == hr 而立即返回，不会递归下去，理由如下 由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 hl == hr，只消耗 $\\mathcal O(\\log N)$ 的复杂度而不会继续递归 "},"Part Three/4栈.html":{"url":"Part Three/4栈.html","title":"4 栈","keywords":"","body":"4 栈 单调栈 Next Greater Number 单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减） 单调栈听起来有点像堆？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element 我们先讲下 Next Greater Number 的原始问题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1 这个问题不好用语言解释清楚，直接上一个例子：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1] 解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1 这个问题可以这样抽象思考： 把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案 代码上可以描述为 vector nextGreaterElement(vector& nums) { vector ans(nums.size()); // 存放答案的数组 stack s; for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放 while (!s.empty() && s.top() 这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个高个元素之间的元素排除，因为他们的存在没有意义，前面挡着个更高的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了 我们分析下它的时间复杂度，要从整体来看：总共有 $n$ 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 $n$ 成正比的，也就是 $\\mathcal O(n)$ 的复杂度 【经典问题分析——下一个更大元素 I】 题目描述 496. 下一个更大元素 I 解法 class Solution { public: vector nextGreaterElement(vector& nums1, vector& nums2) { unordered_map hash; stack s; for (int i = nums2.size() - 1; i >= 0; i--) { while (!s.empty() && s.top() ans; for (auto i: nums1) ans.push_back(hash[i]); return ans; } }; 循环数组 单调栈讲解完毕。下面开始另一个重点：如何处理「循环数组」 同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？ 给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 首先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效： vector arr = {1,2,3,4,5}; int n = arr.size(), index = 0; while (true) { print(arr[index % n]); index++; } 回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于：这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左边 环形数组都有这样的一个处理思路：将原始数组拉长一倍，就是在后面再接一个原始数组，这样的话，按照之前比身高的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了 比较笨的处理方式是，牺牲点空间，把两倍长的数组构造出来 但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟 vector nextGreaterElements(vector& nums) { int n = nums.size(); vector res(n); // 存放结果 stack s; // 假装这个数组长度翻倍了 for (int i = 2 * n - 1; i >= 0; i--) { while (!s.empty() && s.top() 【经典问题分析】503. 下一个更大元素 II "},"Part Four/高级数据结构.html":{"url":"Part Four/高级数据结构.html","title":"Part Four. 高级数据结构","keywords":"","body":"1. 树状数组 名曰树状数组，那么究竟它是树还是数组呢？数组在物理空间上是连续的，而树是通过父子关系关联起来的，而树状数组正是这两种关系的结合，首先在存储空间上它是以数组的形式存储的，即下标连续；其次，对于两个数组下标 $x,y(x 然后我们来看树状数组上的结点Ci具体表示什么，这时候就需要利用树的递归性质了。我们定义Ci的值为它的所有子结点的值 和 Ai 的总和，之前提到当i为奇数时Ci一定为叶子结点，所以有Ci = Ai ( i为奇数 )。 C1 = A1 C2 = C1 + A2 = A1 + A2 C3 = A3 C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4 C5 = A5 C6 = C5 + A6 = A5 + A6 C7 = A7 C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 我们从中可以发现，其实Ci还有一种更加普适的定义，它表示的其实是一段原数组A的连续区间和。 树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)作为一个查询和修改复杂度都为$O(logn)$的数据结构。下面我们就看一下这两个操作的具体实现： 求和操作 查询$[l, r]$的和，即为$sum(r)-sum(l-1)$ int sum(int x){ int s = 0; for(int i=x;i;i-=lowbit(i)) s += c[i]; return s; } 更新操作 void add(int x, int v){ for(int i=x;i lowbit函数实现 int lowbit(int x){ return x&(-x); } 1.1 PUIQ模型 单点更新，区域查询（标准的树状数组） HDU 1166 - 敌兵布阵 POJ 3321 - Apple Tree（将图转换为树状数组） 1.2 降维 总的来说就是，保证树状数组只处理其中的一个维度，至于其他的维度根据题目做不同处理（但都不是利用树状数组进行处理） HDU 1541 - Stars POJ 2481 - Cows1.3 二分模型 POJ 2892 - Tunnel Warfare 1.4 多维树状数组 简单来说就是，用一个树状数组同时处理多个维度 void add(int x, int y, int v) { for(int i=x;i POJ 1195 - Mobile phones 1.5 逆序模型 来看一个给定$n$个元素的排列 $X0,X_1,X_2,…,X{n-2},X{n-1}$,对于某个 $X_i$ 元素，如果想知道以它为\"首\"的逆序对的对数( 形如$(X_iX_j)$ 的逆序对)，就是需要知道 $X{i+1}, … ,X{n-2}, X{n-1}$ 这个子序列中小于 $X_i$ 的元素的个数。 那么我们只需要对这个排列从后往前枚举，每次枚举到 $X_i$ 元素时，执行$cnt += sum(X_i-1)$，然后再执行$add(X_i, 1)$，$n$个元素枚举完毕，得到的$cnt$值就是我们要求的逆序数了。总的时间复杂度$O(nlogn)$ 注意，有些OJ题目给出$X_i$的取值范围很大，而树状数组的树状部分$C[...]$是建立在一个有点像位存储的数组的基础之上的，不是单纯的建立在输入数组之上。所以这时我们会用到离散化，离散化的过程一般为：将$a[...]$升序排列，$index[i]=j$，$i$为排序前元素的下标，$j$为排序后元素的下标。 LeetCode 面试题51 - 数组中的逆序对 同样是用树状数组求逆序数，如果对排列从前往后枚举，则算法过程会有些不同。如果数据不是很大，我们可以将数据一个个插入到树状数组中，每插入一个数（$add(X_i, 1)$），就统计比它小的数的个数$sum(X_i)$，那么$i-sum(X_i)$即为比$X_i$大的个数，也就是$X_i$的逆序数，$cnt+=i-sum(X_i)$. 同时需要注意是否需要先用到离散化。 POJ 2299 - Ultra-QuickSort HDU 1394 - Minimum Inversion Number 1.6 多重树状数组 不同于多维树状数组，这里，我们用到了多个树状数组进行处理 void add(int x, int v, int op){ for(int i=x;i POJ 1990 - MooFest 在多重树状数组下面，有个小分支的情况：有些时候不一定要把 $c[...]$ 数组增加一个维度（即开出两个树状数组来），可以清零后再复用一次，至于这种情况要仔细判断是否真的两个维度是前后执行的，如果是并行执行的，那么还是老老实实的把 $c[...]$ 数组增加一个维度 HDU 2492 - Ping pong 2. 单调队列 举个例子, class MonotonicQueue { //单调队列（从大到小） public: deque que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop (int value) { if (!que.empty() && value == que.front()) { que.pop_front(); } } // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push (int value) { while (!que.empty() && value > que.back()) { que.pop_back(); } que.push_back(value); } // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() { return que.front(); } }; 3 并查集 class DisjoinSetUnion{ private: vector father, rank; int n; public: DisjoinSetUnion(int _n){ n = _n; rank.resize(n, 1); father.resize(n); for(int i=0;i 字典树 Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段： 指向子节点的指针数组 $\\textit{next}$。对于本题而言，数组长度为 $26$，即小写英文字母的数量。此时 $\\textit{next}[0]$ 对应小写字母 $a$，$\\textit{next}[1]$ 对应小写字母 $b$，…，$\\textit{next}[25]$ 对应小写字母 $z$ 布尔字段 $\\textit{isEnd}$，表示该节点是否为字符串的结尾 如下图所示是一个包含 $\\textit{sea, sells, she}$ 的字典树 字典树的数据结构如下，包含了三种常用的操作 insert，search，startsWith class Trie { private: bool isEnd; Trie* next[26]; public: /** Initialize your data structure here. */ Trie() { isEnd = false; memset(next, 0, sizeof(next)); } /** Inserts a word into the trie. */ void insert(string word) { Trie* node = this; for(auto c: word) { if(node->next[c-'a']==NULL) node->next[c-'a'] = new Trie(); node = node->next[c-'a']; } node->isEnd = true; } /** Returns if the word is in the trie. */ bool search(string word) { Trie* node = this; for(auto c: word) { node = node->next[c-'a']; if(node==NULL) return false; } return node->isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { Trie* node = this; for(auto c: prefix) { node = node->next[c-'a']; if(node==NULL) return false; } return true; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); * * or: * Trie trie; * bool param_4 = trie.search(word) */ "},"Part Five/高级算法.html":{"url":"Part Five/高级算法.html","title":"Part Five. 高级算法","keywords":"","body":"﻿@toc 1. 图论 1.1 求强力连通分量——Tarjan算法 Tarjan算法时用来求强连通分量的，它基于一种DFS的算法，每个强连通分量为搜索树的一颗子树 void tarjan(int k){ low[k] = dfn[k] = ++t; f[k] = true; // f[]代表该结点已经入栈 s.push(k); for(int i=fst[k];i!=-1;i=nex[i]){ if(!dfn[v[i]]){ tarjan(v[i]); low[k] = min(low[k],low[v[i]]); } else{ if(f[v[i]]) low[k] = min(low[k], dfn[v[i]]); } } if(low[k]==dfn[k]){ f[k] = false; scc[k] = ++cnt; // cnt记录强连通分量个数，ssc表示k在第cnt个强连通分中 ssize[cnt] = 1; // ssize记录第cnt个强连通分量的成员数 while(s.top()!=k){ scc[s.top()] = cnt; f[s.top()] = false; ssize[cnt]++; s.pop(); } s.pop(); } return; } 洛谷 P2341 - 受欢迎的牛 Reference Tarjan算法 详解+心得 Tarjan 算法[有向图强连通分量] Tarjan算法 最简单，详细的tarjan算法讲解 "},"Part Six/牛客刷题笔记.html":{"url":"Part Six/牛客刷题笔记.html","title":"Part Six. 牛客刷题笔记","keywords":"","body":"图 BFS 小A与小B 题目描述 小A与小B 解法 先解释一下怎样算能遇到，如果一个人走到的点是另一个人曾经走过的点，则他两就算是可以相遇的 对于样例，也就是如上所示的 3 步，两人在最左上的点相遇 解法很简单就是 BFS，注意这里控制 BFS 循环的是时间。所以在一个时间点里面，C 走一次，D 走两次 说一个常用技巧，如何控制移动方向。竖着看，{dx[0], dy[0]} 表示右移一各，C 考虑前 4 组元素，D 考虑整个数组元素 const int dx[]={1,0,-1,0,1,1,-1,-1}; const int dy[]={0,1,0,-1,1,-1,1,-1}; #include #include using namespace std; const int dx[] = {1, 0, -1, 0, 1, 1, -1, -1,}; const int dy[] = {0, 1, 0, -1, 1, -1, 1, -1}; int n, m; char maze[1005][1005]; bool vis[2][1005][1005]; struct node { int x, y; }; queue q[2]; bool check_bfs(int person){ int q_size = q[person].size(); for (int k = 0; k n || new_y m || maze[new_x][new_y] == '#' || vis[person][new_x][new_y]) continue; if (vis[person^1][new_x][new_y]) return true; q[person].push((node){new_x, new_y}); vis[person][new_x][new_y] = 1; } } return false; } int main() { cin >> n >> m; for (int i = 1; i > maze[i][j]; if (maze[i][j] == 'C') { q[0].push((node){i, j}); vis[0][i][j] = 1; } if (maze[i][j] == 'D') { q[1].push((node){i, j}); vis[1][i][j] = 1; } } } int min_t = 0; bool meet = false; while (!q[0].empty() || !q[1].empty()) { meet = 0; min_t++; if (!q[0].empty() && check_bfs(0)) { meet = true; break; } // D 可以走两步 if (!q[1].empty() && check_bfs(1)) { meet = true; break; } if (!q[1].empty() && check_bfs(1)) { meet = true; break; } } if (meet) { cout DP 最大子矩阵 题目描述 最大子矩阵 解法 我们这里要用到前缀和来 这道题有一个特殊的地方 1 ≤ m ≤ 2，也就是说最多我们也只有两列数据要处理 那么我们先问一列的情况怎么处理？如下，dp[i][k] 表示了到数组位置 i 选 k 个段的最大和，sum[i] - sum[l] 是前缀和的知识 for (int l = 0; l 那么两列怎么处理呢？很简单嘛，假如说只在一列选区间，两种情况 // 当仅选取第一列的某段区间时 dp[i][j][k] = max(dp[i][j][k], dp[l][j][k-1]+sum[i][1]-sum[l-1][1]) // 当仅选取第二列的某段区间时 dp[i][j][k] = max(dp[i][j][k], dp[i][l][k-1]+sum[j][2]-sum[l-1][2]) 那两列都选，两列都不选的情况呢？ // 两列都不选 dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]) // i == j 时，两列都选 dp[i][j][k]=max(dp[i][j][k], dp[l][l][k] + sum[i][1] + sum[i][2] - sum[l-1][1] - sum[l-1][2]) 搞定，所有转移情况都已经列出来了 #include using namespace std; #define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); //代码预处理区 const int MAX = 1e2 + 7; int n, m, num; int sum[MAX][2], dp[MAX][MAX][17]; //全局变量区 int main() { IOS; cin >> n >> m >> num; for (int i = 1; i > sum[i][j]; sum[i][j] += sum[i - 1][j]; } for (int i = 1; i 数学考试 题目描述 数学考试 这里重新翻一下题目，出的啥玩意啊，分数还有负数的情况？不连续也描述的不准确 给定一个长度为 $n$ 的整数列，希望从中选出两个不相交的长度为 $k$ 的子数组，要求满足两个子数组和最大 解法 这道题还是 DP + 前缀和 我们用两次 DP 去求 $i$ 左边最大的子数组和右边的子数组，左边的情况很好处理 max_left = max(max_left, presum[i] - presum[i - k]) // i >= k 左边取到最大后，确定右边 ans = max(ans, max_left + presum[i + k] - presum[i]) 完整代码如下所示 #include using namespace std; vector presum(200005, 0); int main(){ int t; cin >> t; while (t--){ int n, k; cin >> n >> k; long long ans = -1e18, left_region = -1e18; for (int i = 1; i > presum[i]; presum[i] += presum[i - 1]; } for (int i = k; i + k Steps to One "}}