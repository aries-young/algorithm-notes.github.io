{"./":{"url":"./","title":"Part Zero. Introduction ","keywords":"","body":"Introduction 常用终端命令 $ gitbook install ./ $ gitbook build ./ .\\algorithm-notes.github.io\\docs $ gitbook serve Katex 语法 Inline math: {% math %}\\int_{-\\infty}^\\infty g(x) dx{% endmath %} Block math: {% math %} \\int_{-\\infty}^\\infty g(x) dx {% endmath %} 正文引用添加方式 > [!note|iconVisibility:hidden] > NOTE > [!tip|iconVisibility:hidden] > TIPS > [!warning|iconVisibility:hidden] > SUPPLEMENT > [!danger|iconVisibility:hidden] > CORE CONTENT "},"Part Two-动态规划/动态规划.html":{"url":"Part Two-动态规划/动态规划.html","title":"Part Two-动态规划专栏","keywords":"","body":"1 动态规划初探 1.1 状态和转移方程 【核心思想】动态规划问题的一般形式就是求最值 为什么说动态规划一般形式就是求最值呢？ 这里给出一个概念『最优子结构』：如果问题的最优解包含的子问题的解也是最优的，就称该问题具有最优子结构，同时满足最优化原理 要符合『最优子结构』，子问题间必须相互独立 动态规划问题一定会具备『最优子结构』，因此就通过子问题的最值得到原问题的最值 【思维框架】 明确『状态』 -> 定义 dp 数组/函数的含义 -> 明确『选择』-> 明确 base case 但是，光光这么说还是会觉得很难定义出合适的状态和转移方程，使得递归正常地进行，毕竟不同的状态定义和状态转移方程都会使得解法的复杂度不同 所以，我们接从递归看起，我个人觉得下面例子真的是很好地从递归出发讲清楚了动态规划是什么 b（￣▽￣）d 1.2 从递归看动态规划 【经典问题分析——凑零钱】 题目描述 322. 零钱兑换 解法 1. 暴力递归 明确『状态』： 也就是原问题和子问题中变换的量，由于硬币数量无限，所以唯一的状态就是目标金额 $amount$ 定义 dp 函数的含义： 当前的目标金额是 $n$，至少需要 $dp(n)$ 个硬币凑出该金额 明确『选择』： 也就是对于每个状态，可以做出什么选择改变当前状态。具体到当前的问题上，无论当前的目标金额是多少，『选择』就是从面额列表 $coins$ 中选择一个硬币，然后目标金额就会减少 def coinChange(coins: List[int], amount: int): # 定义： 要凑出⾦额 n， ⾄少要 dp(n) 个硬币 def dp(n): # 做选择， 选择需要硬币最少的那个结果 for coin in coins: res = min(res, 1 + dp(n - coin)) return res # 我们要求的问题是 dp(amount) return dp(amount) 明确 base case： 显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1 def coinChange(coins: List[int], amount:int): def dp(n): # base case if n == 0: return 0 if n 至此，状态转移方程其实已经完成了 我们来看一下 $amount=11, coins=\\left {1, 2, 5\\right }$ 时的递归树 时间复杂度：子问题总数 × 每个子问题的时间 子问题总数为递归树中结点的个数，这个比较难看出来，是 $\\mathcal O(n^k)$；每个子问题中含有一个 for 循环，复杂度为 $\\mathcal O(k)$，故暴力递归下的总时间复杂度为 $\\mathcal O(k\\times n^k)$ 2. 带备忘录的递归 def coinChange(coin, amount): # 备忘录 memo = dict() def dp(n): # 查备忘录，避免重复计算 if n in memo: return memo[n] if n == 0: return 0 if n 很显然 『备忘录』大大减小了子问题数目，完全消除了子问题冗余的问题，所以子问题总数不会超过金额数 $n$，即子问题复杂度为 $\\mathcal O(n)$，处理一个子问题的时间不变，仍是 $\\mathcal O(k)$，所以总时间复杂度为 $\\mathcal O(kn)$ 3. dp 数组的迭代解法 在上面添加备忘录的代码中已经很接近 dp 的思想了，下面我们看一下 dp 数组的完整解法 $dp[i] = x\\ 表示当目标金额为\\ i\\ 时，\\ 至少需要\\ x\\ 枚硬币$ def coinChange(coins, amount): dp = [amount + 1] * (amount + 1) dp[0] = 0 for i in range(len(dp)): for coin in coins: if i - coin 2 背包问题 2.1 0-1背包、满包 有 $N$ 件物品和一个容量为 $V$ 的背包。放入第 $i$ 件物品耗费的空间是 $C_i$，得到的价值是 $W_i$，求解将哪些物品装入背包可使价值总和最大 基本思路 $f(i, j)$ 表示前 $i$ 件物品放入一个容量为 $j$ 的背包可以获得的最大价值 于是，转移方程可以表述为 f(i,j) = max(f(i-1, j), f(i-1,j-w_i)+v_i) //二维 for(int i=1;i=volume[i]) dp[i][j] = max(dp[i-1][j], m[i-1][j-volume[i]]+value[i]); else dp[i][j] = dp[i-1][j]; } } 优化空间复杂度 // 一维 for(int i=1;i=volume[i];j--) dp[j] = max(dp[j], dp[j-volume[i]]+value[i]); } 满包 满背包与普通背包唯一不同的点就是恰好装满背包所能取得的最大价值，主要区别在于初始化，满包问题的初始条件：$f(1...v)=-\\infty,\\ f(0)=0$ 可以这样理解： $f[...]$ 的初始化状态表示的是没有任何物品可以放入背包时的合法状态，如果要求背包恰好装满，那么初始化 $f(1...v)=0$ 就不对了，因为此时表示恰好装满容量为 $v$ 的背包时物品价值为 0，所以在满包问题中初始化条件为 $f(1...v)=-\\infty,\\ f(0)=0$ 洛谷 P2925 - Hay For Sale S 洛谷 P1164 - 小A点菜 HDU 3466 - Proud Merchants 2.2 完全背包 有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。放入第 $i$ 种物品的耗费的空间是 $C_i$，得到的价值是 $W_i$ 求解：将哪些物品装入背包，可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 for(int i=1;i 这个代码与 0-1 背包的代码只有 $j$ 的循环次序不同而已。为什么这样一改就可行呢？ 首先，想想为什么 0-1 背包中要按照 $j=V...0$ 的逆序来循环？这是因为要保证第 $i$ 次循环中的状态 $f[i][j]$ 是由状态 $f[i−1][j−w[i]]$ 递推而来。换句话说，这正是为了保证每件物品只选一次，在考虑 “ 选入第 $i$ 件物品 ” 时的策略，是依据一个没有选入第 $i$ 件物品的子结果 $f[i−1][j−w[i]]$ 而现在完全背包的特点恰是每种物品可选无限件，所以在考虑 “ 加选一件第 $i$ 种物品 ” 时，却正需要一个可能已选入第 $i$ 种物品的子结果 $f[i][j−w[i]]$，所以就可以并且必须采用$j=0...V$的顺序循环。这就是这个简单的程序为何成立的道理 洛谷 P1616 - 疯狂的采药 HDU 1114 - Piggy-Bank 洛谷 P1853 - 投资的最大效益 LeetCode 面试题 08.11 - 硬币 2.1.3 多重背包 给n种物品和一个容量为v的背包,每种物品最多有num[i]件可用,每个物品都有一个体积volume[i]和价值value[i],求背包最多能装多少价值的物品? 二进制优化 把第$i$种物品换成$p[i]$件0-1背包中的物品，则得到了物品数为$\\sum_i p[i]$的01背包问题，直接求解，复杂度仍然是$O(V*\\sum_i p[i])$。 但是我们期望将它转化为0-1背包问题之后能够像完全背包一样降低复杂度。 仍然考虑二进制的思想，我们考虑把第$i$种物品换成若干件物品，使得原问题中第$i$种物品可取的每种策略——取$0...p[i]$件——均能等价于取若干件代换以后的物品。另外，取超过$p[i]$件的策略必不能出现。 具体方法是：将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为$1,2,4,...,2k−1,p[i]-2^k+1$且$k$是满足$p[i]−2^k+1>0$的最大整数。 例如，如果$p[i]$为13，就将这种物品分成系数分别为1,2,4,6的四件物品。分成的这几件物品的系数和为$p[i]$，表明不可能取多于$p[i]$件的第$i$种物品。另外这种方法也能保证对于$0...p[i]$间的每一个整数，均可以用若干个系数的和表示，这个证明可以分$0...2^{k}-1$和$2^{k}...p[i]$两段来分别讨论得出，并不难。这样就将第$i$种物品分成了$O(log(p[i]))$种物品，将原问题转化为了复杂度为$O(V∗\\sum_i log(p[i]))$的0-1背包问题，是很大的二进制优化 int count = 0, vval[M], vol[M]; // count存分解后的物品总数 //vval存分解后的每件物品的价值 //vvol存分解完成后每件物品的代价 //二进制分解 for(int i=1;i0) { vval[count] = num[i]*val[i]; vol[count] = num[i]*vol[i]; count++; } } // 0-1背包问题 memset(dp, 0, sizeof(dp)) ; for(int i=1;i=vol[i];j--) dp[j] = max(dp[j], dp[j-vol[i]]+val[i]); 简化版本 int dp[M] = {}; for(int i=1;i=k*vol;--j) dp[j] = max(dp[j], dp[j-k*vol]+k*val); for(int j=v;j>=num*vol;--j) dp[j] = max(dp[j], dp[j-num*vol]+num*val); } 单调队列优化 多重背包问题同样有O(VN)的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。 int dp[M]; for(int i=1;i=b[r-1]) tail--; // 出队 a[tail] = j; b[tail++] = y; while(a[head] 这里，应先确保搞明白了单调队列，就是在区间移动时动态维护区间的最值 观察多重背包的转移方程： $f[i][j]=max(f[i−1][j],f[i−1][j−k∗vol[i]]+k∗val[i])$ 单调队列优化的主要思想就是分组更新，因为$vol[i]$是成倍增加的$f[i−1][j]$只会更新$f[i−1][j+k∗w[i]]$（这里是从前往后看的，所以是+）。对于当前$vol$的体积，我们可以按照余数将它分为$vol$组，也就是$0...vol−1$. 并且，同一个剩余系的数在一组,比如在模3意义下，1,4,7,10是一组，2,5,8,11是一组，3,6,9,12是一组每组的转移是互不影响的，也就是单独转移 举个例子 $f[i][5vol] = max(f[i-1][4vol]+val, f[i-1][3vol]+2val, f[i-1][2vol]+3val, f[i-1][vol]+val, f[i-1][0]+5val)$ $f[i][4vol] = max(f[i-1][3vol]+val, f[i-1][2vol]+2val, f[i-1][vol]+3val, f[i-1][vol]+val, f[i-1][0]+4val)$ 让所有$f[i][j]$都减去$j/vol*val$ $f[i][5vol] = max(f[i-1][4vol]-4val, f[i-1][3vol]-3vol, f[i-1][2vol]-2val, f[i-1][vol]-val, f[i-1][0])$ $f[i][4vol] = max(f[i-1][3vol]-3val, f[i-1][2vol]+2val, f[i-1][vol]-2val, f[i-1][vol]-val, f[i-1][0])$ 即$f[i][j]=max(f[i−1][j \\ mod\\ vol+k∗vol]−k∗val+j∗val)$ 当$j\\ mod\\ w$一定后，就可以用单调队列来优化了 HDU 1059 - Dividing 洛谷 - P1776 宝物筛选 2.1.4 混合背包 顾名思义，混合背包就是有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包） 最直接的想法：二进制分解。可以取无限次物品我们就记其num=99999，这样同样可以利用二进制分解开来 void binary_split() { for(int i=1;i=ccost[i];j--) dp[j] = max(dp[j], dp[j-ccost[i]]+vvalue[i]); 洛谷 P1833 - 樱花 2.1.5 二维费用背包 给一个容量为V的背包,你的负重最大只有W,然后有n种物品,每种都有若干个(0个,无限,多个),体积为volume[i],重量为weight[i],价值为value[i].问最多能装多少价值的物品,在不超过体积及负重的情况下? for(int i=1;i=volume[i];j--) for(int k=w;k>=weight[i];k--) dp[j][k]=max(dp[j][k],dp[j-volume[i]][k-weight[i]]+value[i]); 洛谷 P1507 - NASA的食物计划 HDU 2159 - FATE 2.1.7 分组背包 有n件物品可以被放入一个容量为v的背包中,每件物品体积为volume[i],价值为value[i].此外,这些物品被分成p组,每组中的物品最多只能选一件,求背包中最多可以装多少价值的物品. for(int k=1;k=0;j–) //此处遍历顺序与物品种类有关 for(int i: part[k]) dp[j]=max(dp[j],dp[j-volume[i]]+value[i]). 注意遍历方式一定是$kji$,如果是$kij$的话就无法保证每组只选一个了。 先$j$再$i$保证了每组内,每个体积只会被一个最优的物品访问到。 洛谷 P1757 - 通天之分组背包 HDU 1712 - ACboy needs your help 2.1.8 有依赖的背包问题 这种背包问题的物品间存在某种“依赖”的关系。也就是说，物品i依赖于 物品j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物 品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多 件物品。 for(int i=1;i=volume[k];j--) tmp[j]=max(tmp[j],tmp[j-volume[k]]+value[k]); for(int j=v;j>=volume[i];j--) dp[j]=max(dp[j],tmp[j-volume[i]]+value[i]); } 洛谷 P1064 - 金明的预算方案 HDU 3449 - Consumer2.1.9 泛化物品 泛化物品准确来说,不是一类题目，而是一种思想。泛化物品的定义是 考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分 配给它的费用而变化。这就是泛化物品的概念。 or 更严格的定义之。在背包容量为V 的背包问题中，泛化物品是一个定义 域为0 . . . V 中的整数的函数h，当分配给它的费用为v时，能得到的价值就 是h(v)。 or 这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0 . . . V ]， 给它费用v，可得到价值h[v]。 于是， 一个0-1背包中的物品(体积$ci$,价值$wi$),它的泛化物品模型是$h(ci)=wi$，$h(其他)=0$ 一个完全背包中的物品,它的模型是$h(cik)=wik$,其中k为正整数且$ci*k 一个多重背包中的物品,则是$h(cik)=wik$，其中$k 一个互斥的物品组，$h(ci)=wi$，$i$取遍组中物品的编号，$ci$相同时$wi$取最小值，$h(其他)=0$ 泛化物品的和 如果给定两个泛化物品$a$和$b$，现在有体积v来装这两种物品，要求获得最大价值，怎么做? 则$dp[j]=max(a(k)+b(v-k))$，$k$取遍$0$到$j$，答案就是$dp[v]$ 新合成的dp数组，实际上，也是一个泛化物品。 由泛化物品的性质可知，如果将两个泛化物品这样合成一个新的物品，新的物品在问题中完全可以取代原有的两个物品。 2.1.10 背包问题问法的变化 记录具体的选择 如果需要记录具体的选择，可以另起一个 x[ ] 数组，x[i]=0表示不拿，x[i]=1表示拿。 f[n][c]为最优值，如果f[n][c]=f[n-1][c] ,说明有没有第n件物品都一样，则x[n]=0 ; 否则 x[n]=1。当x[n]=0时，由x[n-1][c]继续构造最优解；当x[n]=1时，则由x[n-1][c-w[i]]继续构造最优解。以此类推，可构造出所有的最优解。 for(int i=n;i>1;i--) { if(dp[i][v]==dp[i-1][v]) x[i] = 0; else { x[i] = 1; v -= volume[i]; } x[1] = (dp[1][c]>0)?1:0; } 输出字典序最小的方案 字典序最小是指$N$号物品的选择方案排列出来以后字典序最小 我们的做法是：先把物品逆序排列一下，然后按照前面的状态转移方程来求值。唯一要注意的是，如果$f[i][j]==f[i−1][i−j]f[i][j]$以及$f[i][j]==f[i−1][j−w[i]]+v[i]$同时成立，应该按照后者（即选择了物品$i$）输出 求方案总数 当我们要求装满背包或者将背包装至某一指定容量的方案总数时，一般只需要将转移方程的max改成sum即可。初始条件为$dp[0][0]=1$ 求最优方案的总数 这里与求方案总数不同的是我们要求所装的物品价值最大，于是，结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：$f[i][j]$意义同前述，$g[i][j]$表示这个子问题的最优方案的总数，则在求$f[i][j]$的同时求$g[i][j]$ 求次优解，第K优解 求次优解往往可以相同的复杂度解决，第K优解则比求最优解的复杂度上多一个系数K。其基本思想是将每个状态都表示成有序队列，将状态转移方程中的max/min转化成有序队列的合并。 这里只讲一下0-1背包的情况： 如果要求第K优解，那么状态$f[i][j]$就应该是一个大小为K的数组$f[i][j][1...K]$。其中$f[i][j][k]$表示前i个物品、背包大小为j时，第k优解的值。“$f[i][j]$是一个大小为K的数组”这一句，熟悉C语言的同学可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然$f[i][j][1...K]$这K个数是由大到小排列的，所以我们把它认为是一个有序队列。然后原方程就可以解释为：$f[i][j]$这个有序队列是由$f[i−1][j]$和$f[i−1][j−w[i]]+v[i]$这两个有序队列合并得到的。有序队列f[i−1][j]f[i-1][j]f[i−1][j]即$f[i−1][j][1...K]$，$f[i−1][j−w[i]]+v[i]$则理解为在$f[i−1][j−w[i]][1...K]$的每个数上加上$v[i]$后得到的有序队列。合并这两个有序队列并将结果的前KKK项储存到$f[i][j][1...K]$中的复杂度是$O(K)$。最后的答案是$f[N][V][K]$。总的复杂度是$O(VNK)$。为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为KKK的数组，并在这个数组中有序的保存该状态可取到的前KKK个最优值。那么，对于任两个状态的max运算等价于两个由大到小的有序队列的合并。 HDU 2639 - Bone Collector II 3 股票问题 我们先来推一个范式，问题描述如下 动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解 所以，我们先在这道题中确定出所有的「状态」和「选择」 每天都有三种「选择」：买入、卖出、无操作，我们用 buy，sell，rest 表示这三种选择 「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的rest的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。而 我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，手上的股票都卖出，最多获得多少利润 接着，我们确定一下状态转移 很容易看出，状态转移方程 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 今天选择 rest, 今天选择 sell ) 需要注意 k 的限制，在选择 buy 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 k 应该减小 1 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 今天选择 rest, 今天选择 buy ) 最后，我们确定一下 base dp[-1][...][0] = 0 // 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。 dp[-1][...][1] = -infinity // 解释：还没开始的时候，是不可能持有股票的。 // 因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。 dp[...][0][0] = 0 // 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。 dp[...][0][1] = -infinity // 解释：不允许交易的情况下，是不可能持有股票的。 // 因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。 【经典问题分析——买卖股票的最佳时机】 题目描述 121. 买卖股票的最佳时机 解法 这道题相当于 k=1，我们确定一下这道题的状态转移方程和 base case dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) // 解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。 // 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。 // 可以进行进一步化简去掉所有 k： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) 于是，我们可以直接写出代码 int n = prices.size; vector> dp(n, vector(2, 0)); for (int i = 0; i 显然 i = 0 时 i - 1 是不合法的索引，这是因为我们没有对 i 的 base case 进行处理，可以这样给一个特化处理 if (i - 1 == -1) { dp[i][0] = 0; // 根据状态转移方程可得： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; // 根据状态转移方程可得： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; } 完整的代码如下所示，但是我们仔细观察可以发现在状态转移方程中，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 $O(1)$ // 原始版本 class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); vector> dp(n, vector(2, 0)); for (int i = 0; i & prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i 【经典问题分析——买卖股票的最佳时机 II】 题目描述 122. 买卖股票的最佳时机 II 解法 这道题相当于 k=+infinity，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 完整代码如下所示 class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i 【经典问题分析——最佳买卖股票时机含冷冻期】 题目描述 309. 最佳买卖股票时机含冷冻期 解法 在 k=+infinity 的基础上，加上了冷冻期，也就是每次 sell 之后要等一天才能继续交易 我们可以将这个特点 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]) // 解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。 完整代码如下所示 // 原始版本 class Solution { public: int maxProfit(vector& prices) { int n = prices.size(); vector> dp(n, vector(2, 0)); for (int i = 0; i & prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; int dp_pre_0 = 0; for (int i = 0; i 【经典问题分析——买卖股票的最佳时机含手续费】 题目描述 714. 买卖股票的最佳时机含手续费 解法 在 k=+infinity 的基础上，加上手续费，那么每次交易要支付手续费，只要把手续费从利润中减去即可 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee) // 解释：相当于买入股票的价格升高了。 // 在第一个式子里减也是一样的，相当于卖出股票的价格减小了。 完整代码如下所示 // 原始版本 class Solution { public: int maxProfit(vector& prices, int fee) { int n = prices.size(); vector> dp(n, vector(2, 0)); for (int i = 0; i & prices, int fee) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; for (int i = 0; i 【经典问题分析——买卖股票的最佳时机 III】 题目描述 123. 买卖股票的最佳时机 III 解法 我们先看一下没有空间优化的代码，有两点是明显的不同，都是关于 k 的： 我们前面说到动态规划的核心是穷举所有状态，这里明显 k 出现了多种选择（k=2），所以也要对 k 进行一次循环遍历完所有的状态 其次，在关于 k 循环时，我们选择 k-- 的方式。实际上 dp[i][k] 不会依赖 dp[i][k - 1]，而是依赖 dp[i - 1][k - 1]，对于 dp[i - 1][...]，都是已经计算出来的。所以不管你是 k = max_k, k--，还是 k = 1, k++，都是可以得出正确答案的。但是，我们买股票的初始的「状态」应该是从第 0 天开始，而且还没有进行过买卖，所以最大交易次数限制 k 应该是 max_k；而随着「状态」的推移，你会进行交易，那么交易次数上限 k 应该不断减少，这样一想，k = max_k, k-- 的方式是比较合乎实际场景的 // 原始版本 class Solution { public: int maxProfit(vector& prices) { int max_k = 2, n = prices.size(); int dp[n][max_k + 1][2]; memset(dp, 0, sizeof(dp)); for (int i = 0; i = 1; k--) { if (i - 1 == -1) { dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; } dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]); dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]); } } return dp[n - 1][max_k][0]; } }; // 空间优化版本 class Solution { public: int maxProfit(vector& prices) { int dp_i10 = 0, dp_i11 = INT_MIN; int dp_i20 = 0, dp_i21 = INT_MIN; for (int price: prices) { // 状态转移方程： // dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]) // dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]) // dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) // dp[i][1][1] = max(dp[i-1][1][1], -prices[i]) dp_i20 = max(dp_i20, dp_i21 + price); dp_i21 = max(dp_i21, dp_i10 - price); dp_i10 = max(dp_i10, dp_i11 + price); dp_i11 = max(dp_i11, -price); } return dp_i20; } }; 【经典问题分析——买卖股票的最佳时机 IV】 题目描述 188. 买卖股票的最佳时机 IV 解法 这里有个小技巧，防止直接套用上题代码会超内存：一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity class Solution { public: int maxProfit(int k, vector& prices) { int max_k = k, n = prices.size(); if (n == 0) return 0; if (max_k > n / 2) return max_k_inf(prices); // base case： // dp[-1][...][0] = dp[...][0][0] = 0 // dp[-1][...][1] = dp[...][0][1] = -infinity int dp[n][max_k + 1][2]; // k = 0 时的 base case for (int i = 0; i = 1; k--) { if (i - 1 == -1) { // 处理 i = -1 时的 base case dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; } dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]); dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]); } } return dp[n - 1][max_k][0]; } int max_k_inf(vector& prices) { int n = prices.size(); int dp_i_0 = 0, dp_i_1 = INT_MIN; int dp_pre_0 = 0; for (int i = 0; i 4 House Robber 【经典问题分析——打家劫舍】 题目描述 198. 打家劫舍 解法 这道题也是一个很典型的 DP 问题，「状态」和「选择」也很明确：你面前房子的索引就是状态，抢和不抢就是选择 同样的这里在对于同一 start 位置，是存在重叠子问题的，所以我们可以用备忘录优化 那么自顶向下的解法就可描述为 private int[] memo; // 主函数 public int rob(int[] nums) { // 初始化备忘录 memo = new int[nums.length]; Arrays.fill(memo, -1); // 强盗从第 0 间房子开始抢劫 return dp(nums, 0); } // 返回 dp[start..] 能抢到的最大值 private int dp(int[] nums, int start) { if (start >= nums.length) { return 0; } // 避免重复计算 if (memo[start] != -1) return memo[start]; int res = Math.max(dp(nums, start + 1), nums[start] + dp(nums, start + 2)); // 记入备忘录 memo[start] = res; return res; } 我们把它改为自底向上的解法 int rob(int[] nums) { int n = nums.length; // dp[i] = x 表示： // 从第 i 间房子开始抢劫，最多能抢到的钱为 x // base case: dp[n] = 0 int[] dp = new int[n + 2]; for (int i = n - 1; i >= 0; i--) { dp[i] = Math.max(dp[i + 1], nums[i] + dp[i + 2]); } return dp[0]; } 同样的，我们做一个空间复杂度优化，最终的结果就是 class Solution { public: int rob(vector& nums) { int n = nums.size(); int dp_i_1 = 0, dp_i_2 = 0, dp_i = 0; for (int i = n -1; i >= 0; i--) { dp_i = max(dp_i_1, nums[i] + dp_i_2); dp_i_2 = dp_i_1; dp_i_1 = dp_i; } return dp_i; } }; 【经典问题分析——打家劫舍 II】 题目描述 213. 打家劫舍 II 解法 在上道题的情况下，我们这里将房子排成了一个圈，相当于第一间房子和最后一间房子也相当于是相邻的，不能同时抢。那么我们这里分三种情况来看看：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢 很显然，情况一无论如何都可能比情况二、三小，因为它能选择的范围都要比情况二、三少一个，所以我们不研究情况一 那么事情就好办多了，我们按照情况二走一遍 DP，按照情况三走一遍 DP，取两者最大的结果即可 class Solution { public: int rob(vector& nums) { int n = nums.size(); if (n == 1) return nums[0]; return max(dp(nums, 0, n - 2), dp(nums, 1, n - 1)); } int dp(vector& nums, int start, int end) { int n = nums.size(); int dp_i_1 = 0, dp_i_2 = 0, dp_i = 0; for (int i = end; i >= start; i--) { dp_i = max(dp_i_1, nums[i] + dp_i_2); dp_i_2 = dp_i_1; dp_i_1 = dp_i; } return dp_i; } }; 【经典问题分析——打家劫舍 III】 题目描述 337. 打家劫舍 III 解法 现在我们的房屋不是一排，也不是环状了，我们的房屋是一棵二叉树，道理还是一样的，这里我们按照自顶向下的方法用递归去做吧 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map memo; int rob(TreeNode* root) { if (root == nullptr) return 0; if (memo.find(root) != memo.end()) return memo[root]; // 抢 int do_it = root->val + (root->left == nullptr ? 0 : rob(root->left->left) + rob(root->left->right)) + (root->right == nullptr? 0 : rob(root->right->left) + rob(root->right->right)); // 不抢 int not_do = rob(root->left) + rob(root->right); int res = max(do_it, not_do); memo[root] = res; return res; } }; 同样，我们还是尝试优化下备忘录，不使用额外的备忘录，虽然不会改变算法的时间复杂度（$\\mathcal O(N)$），但是减少了一定的数据操作复杂性，在实际运行上效率会更快一些 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int rob(TreeNode* root) { vector res = dp(root); return max(res[0], res[1]); } /* 返回一个大小为 2 的数组 arr arr[0] 表示不抢 root 的话，得到的最大钱数 arr[1] 表示抢 root 的话，得到的最大钱数 */ vector dp(TreeNode* root) { if (root == nullptr) return {0, 0}; vector left = dp(root->left); vector right = dp(root->right); int rob = root->val + left[0] + right[0]; int not_rob = max(left[0], left[1]) + max(right[0], right[1]); return {not_rob, rob}; } }; "},"Part Three-基础数据结构/1数组.html":{"url":"Part Three-基础数据结构/1数组.html","title":"1 数组","keywords":"","body":"1 数组 二维数组转转转 【经典问题】旋转图像 题目描述 48. 旋转图像 解法 有时候咱们拍脑袋的常规思维，在计算机看来可能并不是最优雅的；但是计算机觉得最优雅的思维，对咱们来说却不那么直观 所以这道题的计算机流程应该是这样的，先按照左上到右下的对角线进行镜像对称，然后翻转每一行 class Solution { public: void rotate(vector>& matrix) { int n = matrix.size(); for (int i = 0; i & nums){ int i = 0, j = nums.size() - 1; while (j > i){ swap(nums[i], nums[j]); i++; j--; } } }; 发散一下，既然会了顺时针旋转 90 度，那逆时针呢？ 思路是类似的，只要通过另一条对角线镜像对称矩阵，然后再反转每一行，就得到了逆时针旋转矩阵的结果 class Solution { public: void rotate(vector>& matrix) { int n = matrix.size(); for (int i = 0; i & nums){ int i = 0, j = nums.size() - 1; while (j > i){ swap(nums[i], nums[j]); i++; j--; } } }; 【经典问题】螺旋矩阵 题目描述 54. 螺旋矩阵 解法 解题的核心思路是按照右、下、左、上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界： 随着螺旋遍历，相应的边界会收缩，直到螺旋遍历完整个数组： class Solution { public: vector spiralOrder(vector>& matrix) { int m = matrix.size(), n = matrix[0].size(); int upper_bound = 0, lower_bound = m - 1; int left_bound = 0, right_bound = n - 1; vector res; while ( res.size() = left_bound; j--){ res.push_back(matrix[lower_bound][j]); } lower_bound--; } if (left_bound = upper_bound; i--){ res.push_back(matrix[i][left_bound]); } left_bound++; } } return res; } }; 【经典问题】螺旋矩阵 II 题目描述 59. 螺旋矩阵 II 解法 和上面一样，不过我们在转圈的时候将数字填入矩阵 class Solution { public: vector> generateMatrix(int n) { int upper_bound = 0, lower_bound = n - 1; int left_bound = 0, right_bound = n - 1; vector> matrix(n, vector(n)); int num = 1; while ( num = left_bound; j--){ matrix[lower_bound][j] = num++; } lower_bound--; } if (left_bound = upper_bound; i--){ matrix[i][left_bound] = num++; } left_bound++; } } return matrix; } }; "},"Part Three-基础数据结构/2链表.html":{"url":"Part Three-基础数据结构/2链表.html","title":"2 链表","keywords":"","body":"2 链表 链表是个老生常谈的问题，这里我们做一个小结。关于链表还有一部分内容是在指针那一块 【经典问题分析——合并两个有序链表】 题目描述 21. 合并两个有序链表 解法 解法有递归和迭代两种，这里我们介绍迭代，还有一种递归的方法应该很容易想到，可以参考 LeetCode 21 - 合并两个有序链表 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode newhead(0); ListNode* p = &newhead; while (list1 != nullptr && list2 != nullptr) { if (list1->val > list2->val) { p->next = list2; list2 = list2->next; } else { p->next = list1; list1 = list1->next; } p = p->next; } p->next = list1 ? list1 : list2; return newhead.next; } }; 【经典问题分析——合并K个有序链表】 题目描述 23. 合并K个升序链表 解法 这里会用到一个数据结构叫做优先级队列，也就是二叉堆，关于二叉堆我们不需要自己手动从底层实现，调用下 C++ STL 中的 priority_queue 关于这道题还有一种分治的解法，可以参考 LeetCode 23 - 合并k个排序链表 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: struct cmp{ bool operator()(ListNode* a, ListNode* b) { return a->val > b->val; } }; ListNode* mergeKLists(vector& lists) { priority_queue, cmp> heapk; for (auto p: lists) if (p != nullptr) heapk.push(p); ListNode* phead = new ListNode(-1); ListNode* pcur = phead; while (!heapk.empty()) { ListNode* top = heapk.top(); heapk.pop(); pcur->next = top; pcur = pcur->next; if (top->next!=nullptr) heapk.push(top->next); } return phead->next; } }; 弹出操作时，比较操作的代价会被优化到 $\\mathcal O(\\log k)$。同时，找到最小值节点的时间开销仅仅为 $\\mathcal O(1)$ "},"Part Three-基础数据结构/3树.html":{"url":"Part Three-基础数据结构/3树.html","title":"3 树","keywords":"","body":"3 树 二叉树构造 【经典问题】最大二叉树 654. 最大二叉树 解法 采用二分法，对于每个根节点找到当前范围中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可 class Solution { public: TreeNode* constructMaximumBinaryTree(vector& nums) { return build(nums, 0, nums.size() - 1); } TreeNode* build(vector& nums, int low, int high){ if (low > high) return nullptr; int index = -1, max_val = INT_MIN; for (int i = low; i left = build(nums, low, index - 1); root->right = build(nums, index + 1, high); return root; } }; 【经典问题】从前序与中序遍历序列构造二叉树 问题描述 105. 从前序与中序遍历序列构造二叉树 解法1——递归 具体从前序结果和中序结果构造二叉树的流程就不再介绍，这里给出一幅图说一下关于索引的确定 int leftSize = index - inStart; root->left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); root->right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); 完整代码如下 class Solution { public: TreeNode* buildTree(vector& preorder, vector& inorder) { return helper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); } TreeNode* helper(vector& preorder, int prestart, int preend, vector& inorder, int instart, int inend){ if (prestart > preend) return nullptr; int rootval = preorder[prestart], indx = 0; for (int i = instart; i left = helper(preorder, prestart + 1, prestart + leftsize, inorder, instart, indx - 1); root->right = helper(preorder, prestart + leftsize + 1, preend, inorder, indx + 1, inend); return root; } }; 解法 2——迭代 迭代的算法流程： 我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点 我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子；如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子 无论是哪一种情况，我们最后都将当前的节点入栈 看下面流程图是分清楚，入栈的过程就是在构建左子树，而出栈的过程就是回溯，找到合适的右孩子插入位置 这样做的依据是： 对于前序遍历中的任意两个连续节点 $u$ 和 $v$，根据前序遍历的流程，我们可以知道 $u$ 和 $v$ 只有两种可能的关系： $v$ 是 $u$ 的左儿子。这是因为在遍历到 $u$ 之后，下一个遍历的节点就是 $u$ 的左儿子，即 $v$； $u$ 没有左儿子，并且 $v$ 是 $u$ 的某个祖先节点（或者 $u$ 本身）的右儿子。如果 $u$ 没有左儿子，那么下一个遍历的节点就是 $u$ 的右儿子。如果 $u$ 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 $u$ 不在它的右儿子的子树中）的节点 $u_a$ ，那么 $v$ 就是 $u_a$ 的右儿子 简单来说，$v$ 要是 $u$ 的左儿子，在中序遍历中 $v$ 比出现在 $u$ 的左边 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* buildTree(vector& preorder, vector& inorder) { if (!preorder.size()) { return nullptr; } TreeNode* root = new TreeNode(preorder[0]); stack st; st.push(root); int inorderIndex = 0; for (int i = 1; i val != inorder[inorderIndex]){ node->left = new TreeNode(preorderVal); st.push(node->left); } else{ while (!st.empty() && st.top()->val == inorder[inorderIndex]){ node = st.top(); st.pop(); ++inorderIndex; } node->right = new TreeNode(preorderVal); st.push(node->right); } } return root; } }; 【经典问题】从中序与后序遍历序列构造二叉树 问题描述 106. 从中序与后序遍历序列构造二叉树 解法 具体从后序结果和中序结果构造二叉树的流程就不再介绍，这里给出一幅图说一下关于索引的确定 int leftSize = index - inStart; root.left = build(inorder, inStart, index - 1, postorder, postStart, postStart + leftSize - 1); root.right = build(inorder, index + 1, inEnd, postorder, postStart + leftSize, postEnd - 1); 完整代码如下 class Solution { public: TreeNode* buildTree(vector& inorder, vector& postorder) { return helper(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1); } TreeNode* helper(vector& inorder, int inStart, int inEnd, vector& postorder, int postStart, int postEnd){ if (inStart > inEnd) return nullptr; int root_val = postorder[postEnd]; TreeNode* root = new TreeNode(root_val); int index = -1; for (int i = inStart; i left = helper(inorder, inStart, index - 1, postorder, postStart, postStart + leftSize - 1); root->right = helper(inorder, index + 1, inEnd, postorder, postStart + leftSize, postEnd - 1); return root; } }; 【经典问题】根据前序和后序遍历构造二叉树 问题描述 889. 根据前序和后序遍历构造二叉树 解法 首先通过数据结构都知道，前序加后序并不能唯一确定一棵二叉树，但是不要紧，我们依然还是能够通过递归构造出一棵可能的二叉树，具体流程如下 首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值 然后把前序遍历结果的第二个元素作为左子树的根节点的值（实际上，如果根节点的左子树有可能是空指针，那么此时的这个元素就应该是右子树的根节点，所以导致了二叉树结构不唯一，如下图所示） 在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可 例如，$\\text{preorder} = [1,2,3], \\text{postorder} = [3,2,1]$ 这里给出一幅图说一下关于索引的确定 class Solution { public: TreeNode* constructFromPrePost(vector& preorder, vector& postorder) { return helper(preorder, 0, preorder.size() - 1, postorder, 0, postorder.size() - 1); } TreeNode* helper(vector& preorder, int preStart, int preEnd, vector& postorder, int postStart, int postEnd){ if (preStart > preEnd) return nullptr; if (preStart == preEnd) { TreeNode* tmp = new TreeNode(preorder[preStart]); return tmp; } int root_val = preorder[preStart]; TreeNode* root = new TreeNode(root_val); int root_left_val = preorder[preStart + 1]; int index = -1; for (int i = postStart; i left = helper(preorder, preStart + 1, preStart + leftSize, postorder, postStart, index); root->right = helper(preorder, preStart + leftSize + 1, preEnd, postorder, index + 1, postEnd - 1); return root; } }; 至此，我们就把中后序构造二叉树的常见问题讲完了 二叉树遍历 前中后序遍历 void traverse(TreeNode* root) { if (root == nullptr) { return; } // 前序位置 traverse(root->left); // 中序位置 traverse(root->right); // 后序位置 } 层遍历 void levelTraverse(TreeNode* root) { if (root == nullptr) return; queue q; q.push(root); // 从上到下遍历二叉树的每一层 while (!q.empty()) { int sz = q.size(); // 从左到右遍历每一层的每个节点 for (int i = 0; i left != nullptr) { q.push(cur->left); } if (cur->right != nullptr) { q.push(cur->right); } } } } 二叉树序列化 二叉树序列化最基础的一个问题就是 LeetCode 297，我们知道要唯一确定一棵二叉树，要么是前序 + 中序，要么是中序 + 后序。但是，在这道题中前序遍历的结果记录了空指针的信息，那么就可以序列化结果唯一确定一棵二叉树 下面展示通过前序、后续和层序遍历序列化和反序列二叉树，但是注意我们唯独没有中序遍历序列化和反序列二叉树，不是序列化做不到，而是反序列化做不到，原因很简单，前序遍历和后序遍历根结点都是在固定的位置（数组的开头 / 结尾），但是中序遍历的结果导致根结点在数组中间，我们没办法确切判断数组中的哪一个数是我们的根结点 【经典问题】二叉树的序列化与反序列化 问题描述 297. 二叉树的序列化与反序列化 解法 1——前序遍历 class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string str = \"\"; serialize_helper(root, str); return str; } void serialize_helper(TreeNode* root, string& str){ if (root == nullptr){ str += \"None,\"; return; } str += to_string(root->val) + ','; serialize_helper(root->left, str); serialize_helper(root->right, str); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { list nodes; string str; for (auto& ch: data){ if (ch == ',') { nodes.push_back(str); str.clear(); } else { str.push_back(ch); } } return deserialize_helper(nodes); } TreeNode* deserialize_helper(list& nodes){ if (nodes.empty()) return nullptr; string first = nodes.front(); nodes.pop_front(); if (first==\"None\") return nullptr; TreeNode* root = new TreeNode(stoi(first)); root->left = deserialize_helper(nodes); root->right = deserialize_helper(nodes); return root; } }; 解法 2——后序遍历 class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string str = \"\"; serialize_helper(root, str); return str; } void serialize_helper(TreeNode* root, string& str){ if (root == nullptr){ str += \"None,\"; return; } serialize_helper(root->left, str); serialize_helper(root->right, str); /********后序位置********/ str += to_string(root->val) + ','; /**********************/ } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { list nodes; string str; for (auto& ch: data){ if (ch == ',') { nodes.push_back(str); str.clear(); } else { str.push_back(ch); } } return deserialize_helper(nodes); } TreeNode* deserialize_helper(list& nodes){ if (nodes.empty()) return nullptr; /********从后往前取出元素********/ string last = nodes.back(); nodes.pop_back(); /******************************/ if (last==\"None\") return nullptr; TreeNode* root = new TreeNode(stoi(last)); /********先构造右子树，后构造左子树********/ root->right = deserialize_helper(nodes); root->left = deserialize_helper(nodes); /***************************************/ return root; } }; 解法 3——层序遍历 String SEP = \",\"; String NULL = \"#\"; /* 将二叉树序列化为字符串 */ String serialize(TreeNode root) { if (root == null) return \"\"; StringBuilder sb = new StringBuilder(); // 初始化队列，将 root 加入队列 Queue q = new LinkedList<>(); q.offer(root); while (!q.isEmpty()) { TreeNode cur = q.poll(); /* 层级遍历代码位置 */ if (cur == null) { sb.append(NULL).append(SEP); continue; } sb.append(cur.val).append(SEP); /*****************/ q.offer(cur.left); q.offer(cur.right); } return sb.toString(); } /* 将字符串反序列化为二叉树结构 */ TreeNode deserialize(String data) { if (data.isEmpty()) return null; String[] nodes = data.split(SEP); // 第一个元素就是 root 的值 TreeNode root = new TreeNode(Integer.parseInt(nodes[0])); // 队列 q 记录父节点，将 root 加入队列 Queue q = new LinkedList<>(); q.offer(root); for (int i = 1; i 二叉树思维 二叉树解题的思维模式分两类： 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式 【经典问题】翻转二叉树 问题描述 226. 翻转二叉树 翻转二叉树是一道典型的二叉树思维题目，遍历：在前序遍历中翻转左右子节点；分解：先翻转左右子树，然后交换左右子节点 解法 1——遍历 class Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return nullptr; TreeNode* left = invertTree(root->left); TreeNode* right = invertTree(root->right); root->left = right; root->right = left; return root; } }; 解法 2——分解 class Solution { public: TreeNode* invertTree(TreeNode* root) { if (root == nullptr) return nullptr; TreeNode* tmp = root->left; root->left = root->right; root->right = tmp; invertTree(root->left); invertTree(root->right); return root; } }; 【经典问题】填充节点的右侧指针 问题描述 116. 填充每个节点的下一个右侧节点指针 解法 采用遍历的思路，做法是先序遍历的时候将每两个子节点连接起来，但是注意下图所示的 5、6节点它们的父节点不同，所以需要特殊的一步来连起这个空隙 class Solution { public: Node* connect(Node* root) { if (root == nullptr) return root; connectTwoNode(root->left, root->right); return root; } void connectTwoNode(Node* node1, Node* node2){ if (node1 == nullptr || node2 == nullptr) return; node1->next = node2; connectTwoNode(node1->left, node1->right); connectTwoNode(node2->left, node2->right); connectTwoNode(node1->right, node2->left); } }; 【经典问题】 114. 二叉树展开为链表 解法 这道题不建议采用遍历的思路，因为我们需要额外空间来随遍历构造链表，采用分解的思路即可以实现原地操作 如下图所示，先压左边，再压右边，最后回到根结点上将原先的右子树接到当前右子树的末端 class Solution { public: void flatten(TreeNode* root) { if (root == nullptr) return; flatten(root->left); flatten(root->right); TreeNode* left = root->left; TreeNode* right = root->right; root->left = nullptr; root->right = left; TreeNode* p = root; while (p->right != nullptr) p = p->right; p->right = right; } }; 二叉搜索树——特性 我们知道二叉搜索树最大的特点就是中序遍历的结果即是一个升序排序的结果 【经典问题分析——二叉搜索树中第K小的元素】 题目描述 230. 二叉搜索树中第K小的元素 解法： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int res = 0, rank = 0; int kthSmallest(TreeNode* root, int k){ traverse(root, k); return res; } void traverse(TreeNode* root, int k){ if (root == nullptr) return; traverse(root->left, k); rank++; if (k == rank) res = root->val; traverse(root->right, k); } }; 我们考虑一个情景，如果按照上面的做法，每次寻找第 k 小的元素就要进行一次中序遍历，最坏的时间复杂度是 $\\mathcal O(N)$，要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是$\\mathcal O(\\log N)$ 的复杂度，让你算一个第 k 小元素，时间复杂度竟然要 $\\mathcal O(N)$，有点低效了 有没有办法改进一下呢？有，记录子树的结点数即可 想找到第 k 小的元素，或者说找到排名为 k 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几 比如说你让我查找排名为 k 的元素，当前节点知道自己排名第 m，那么我可以比较 m 和 k 的大小： 如果 m == k ，显然就是找到了第 k 个元素，返回当前节点就行了 如果 k 如果 k > m，那说明排名第 k 的元素在右子树，所以可以去右子树搜索第 k - m - 1 个元素 这样就可以将时间复杂度降到 $\\mathcal O(\\log N)$ 了 那么，如何让每一个节点知道自己的排名呢？ 这就是我们之前说的，需要在二叉树节点中维护额外信息。每个节点需要记录，以自己为根的这棵二叉树有多少个节点 也就是说，我们 TreeNode 中的字段应该如下： class TreeNode { int val; // 以该节点为根的树的节点总数 int size; TreeNode left; TreeNode right; } 具体如何实现上面说的算法呢，在不能重新定义 TreeNode 的情况下？如下所示，用一个 map 来存储节点和子树的节点数即可 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class MyBST{ public: MyBST(TreeNode* root){ this->root = root; countNodeNum(root); } int kthSmallest(int k){ TreeNode* node = root; while (node != nullptr) { int left = getNodeNum(node->left); if (left right; k -= left + 1; } else if (left == k - 1) break; else node = node->left; } return node->val; } private: TreeNode* root; unordered_map nodeNum; int countNodeNum(TreeNode* node){ if (node == nullptr) return 0; nodeNum[node] = 1 + countNodeNum(node->left) + countNodeNum(node->right); return nodeNum[node]; } int getNodeNum(TreeNode* node){ if (node != nullptr && nodeNum.count(node)) return nodeNum[node]; else return 0; } }; class Solution { public: int kthSmallest(TreeNode* root, int k) { MyBST bst(root); return bst.kthSmallest(k); } }; 二叉搜索树——构造 在这一节我们将探讨如何实现 BST 的基本操作：判断 BST 的合法性、增、删、查 判断 BST 的合法性 一个易犯的错是只比较结点和它的左右孩子，正确的操作是比较结点和它的整个左右子树，代码实现如下 bool isValidBST(TreeNode* root) { return helper(root, nullptr, nullptr); } /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */ bool helper(TreeNode* root, TreeNode* min, TreeNode* max) { // base case if (root == nullptr) return true; // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST if (min != nullptr && root.val = max.val) return false; // 限定左子树的最大值是 root.val，右子树的最小值是 root.val return isValidBST(root->left, min, root) && isValidBST(root->right, root, max); } 对应 LeetCode 的题目是 98. 验证二叉搜索树，因为比较简单就不再详细列出 在 BST 中搜索一个数 在 BST 中搜索一个数，用不到遍历整棵树，用二分的思想就可以 bool isInBST(TreeNode* root, int target) { if (root == nullptr) return false; if (root->val == target) return true; if (root->val right, target); if (root->val > target) return isInBST(root->left, target); } 对应 LeetCode 的题目是 700. 二叉搜索树中的搜索 在 BST 中插入一个数 插入一个数即在 BST 中先找到其对应的位置，在空指针处插入即可 TreeNode* insertIntoBST(TreeNode* root, int val) { // 找到空位置插入新节点 if (root == nullptr) { TreeNode* node = new TreeNode(val); return node; } // if (root.val == val) // BST 中一般不会插入已存在元素 if (root->val right = insertIntoBST(root->right, val); if (root->val > val) root->left = insertIntoBST(root->left, val); return root; } 对应 LeetCode 的题目是 701. 二叉搜索树中的插入操作 在 BST 中删除一个数 删除有点稍微复杂，我们分情况讨论一下 情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以直接删除 if (root->left == nullptr && root->right == nullptr) return nullptr; 情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置 // 排除了情况 1 之后 if (root->left == null) return root->right; if (root->right == null) return root->left; 情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己 我们取后一种情况来说明 if (root->left != null && root->right != null) { // 找到右子树的最小节点 TreeNode* minNode = getMin(root->right); // 把 root 改成 minNode root->val = minNode->val; // 转而去删除 minNode root->right = deleteNode(root->right, minNode->val); } 完整的删除代码如下所示 TreeNode* deleteNode(TreeNode* root, int key) { if (root == nullptr) return nullptr; if (root->val == key) { // 这两个 if 把情况 1 和 2 都正确处理了 if (root->left == nullptr) return root->right; if (root->right == nullptr) return root->left; // 处理情况 3 TreeNode* minNode = getMin(root->right); root->val = minNode->val; root->right = deleteNode(root->right, minNode->val); } else if (root->val > key) { root->left = deleteNode(root->left, key); } else if (root->val right = deleteNode(root->right, key); } return root; } TreeNode* getMin(TreeNode* node) { // BST 最左边的就是最小的 while (node->left != nullptr) node = node->left; return node; } 注意一下，这个删除操作并不完美，因为我们一般不会通过 root.val = minNode.val 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 root 和 minNode 两个节点。因为具体应用中，val 域可能会是一个复杂的数据结构，修改起来非常麻烦；而链表操作无非改一改指针，而不会去碰内部数据 对应 LeetCode 的题目是 450. 删除二叉搜索树中的节点 完全二叉树和满二叉树 二叉树里面有两个特例，一个是满二叉树，一个是完全二叉树。如果要计算满满二叉树的节点数，其实很简单，根据节点总数和树的高度的指数关系既可以得到。那么完全二叉树呢？遍历一棵二叉树的时间复杂度是 $\\mathcal O(N)$，有没有更高效一点的方法呢？有，且时间复杂度为 $\\mathcal O(\\log N * \\log N)$，具体代码如下所示 int countNodes(TreeNode* root) { TreeNode* l = root; TreeNode* r = root; // 记录左、右子树的高度 int hl = 0, hr = 0; while (l != nullptr) { l = l->left; hl++; } while (r != nullptr) { r = r->right; hr++; } // 如果左右子树的高度相同，则是一棵满二叉树 if (hl == hr) { return int(pow(2, hl) - 1); } // 如果左右高度不同，则按照普通二叉树的逻辑计算 return 1 + countNodes(root->left) + countNodes(root->right); } 我们直觉感觉好像最坏情况下是 $\\mathcal O(N*\\log N)$ 吧，因为之前的 while 需要 $\\log N$ 的时间，最后要 $\\mathcal O(N)$ 的时间向左右子树递归 return 1 + countNodes(root->left) + countNodes(root->right); 但事实上，这两个递归只有一个会真的递归下去，另一个一定会触发 hl == hr 而立即返回，不会递归下去，理由如下 由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 hl == hr，只消耗 $\\mathcal O(\\log N)$ 的复杂度而不会继续递归 "},"Part Three-基础数据结构/4栈.html":{"url":"Part Three-基础数据结构/4栈.html","title":"4 栈","keywords":"","body":"4 栈 单调栈 Next Greater Number 单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减） 单调栈听起来有点像堆？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element 我们先讲下 Next Greater Number 的原始问题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1 这个问题不好用语言解释清楚，直接上一个例子：给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1] 解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1 这个问题可以这样抽象思考： 把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案 代码上可以描述为 vector nextGreaterElement(vector& nums) { vector ans(nums.size()); // 存放答案的数组 stack s; for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放 while (!s.empty() && s.top() 这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个高个元素之间的元素排除，因为他们的存在没有意义，前面挡着个更高的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了 我们分析下它的时间复杂度，要从整体来看：总共有 $n$ 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 $n$ 成正比的，也就是 $\\mathcal O(n)$ 的复杂度 【经典问题分析——下一个更大元素 I】 题目描述 496. 下一个更大元素 I 解法 class Solution { public: vector nextGreaterElement(vector& nums1, vector& nums2) { unordered_map hash; stack s; for (int i = nums2.size() - 1; i >= 0; i--) { while (!s.empty() && s.top() ans; for (auto i: nums1) ans.push_back(hash[i]); return ans; } }; 循环数组 单调栈讲解完毕。下面开始另一个重点：如何处理「循环数组」 同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？ 给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,4]。拥有了环形属性，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 首先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效： vector arr = {1,2,3,4,5}; int n = arr.size(), index = 0; while (true) { print(arr[index % n]); index++; } 回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于：这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左边 环形数组都有这样的一个处理思路：将原始数组拉长一倍，就是在后面再接一个原始数组，这样的话，按照之前比身高的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了 比较笨的处理方式是，牺牲点空间，把两倍长的数组构造出来 但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟 vector nextGreaterElements(vector& nums) { int n = nums.size(); vector res(n); // 存放结果 stack s; // 假装这个数组长度翻倍了 for (int i = 2 * n - 1; i >= 0; i--) { while (!s.empty() && s.top() 【经典问题分析】503. 下一个更大元素 II "},"Part Four-高级数据结构/高级数据结构.html":{"url":"Part Four-高级数据结构/高级数据结构.html","title":"Part Four-高级数据结构","keywords":"","body":"树状数组 名曰树状数组，那么究竟它是树还是数组呢？数组在物理空间上是连续的，而树是通过父子关系关联起来的，而树状数组正是这两种关系的结合，首先在存储空间上它是以数组的形式存储的，即下标连续；其次，对于两个数组下标 $x,y(x 然后我们来看树状数组上的结点Ci具体表示什么，这时候就需要利用树的递归性质了。我们定义Ci的值为它的所有子结点的值 和 Ai 的总和，之前提到当i为奇数时Ci一定为叶子结点，所以有Ci = Ai ( i为奇数 )。 C1 = A1 C2 = C1 + A2 = A1 + A2 C3 = A3 C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4 C5 = A5 C6 = C5 + A6 = A5 + A6 C7 = A7 C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 我们从中可以发现，其实Ci还有一种更加普适的定义，它表示的其实是一段原数组A的连续区间和。 树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)作为一个查询和修改复杂度都为$O(logn)$的数据结构。下面我们就看一下这两个操作的具体实现： 求和操作 查询$[l, r]$的和，即为$sum(r)-sum(l-1)$ int sum(int x){ int s = 0; for(int i=x;i;i-=lowbit(i)) s += c[i]; return s; } 更新操作 void add(int x, int v){ for(int i=x;i lowbit函数实现 int lowbit(int x){ return x&(-x); } 1.1 PUIQ模型 单点更新，区域查询（标准的树状数组） HDU 1166 - 敌兵布阵 POJ 3321 - Apple Tree（将图转换为树状数组） 1.2 降维 总的来说就是，保证树状数组只处理其中的一个维度，至于其他的维度根据题目做不同处理（但都不是利用树状数组进行处理） HDU 1541 - Stars POJ 2481 - Cows1.3 二分模型 POJ 2892 - Tunnel Warfare 1.4 多维树状数组 简单来说就是，用一个树状数组同时处理多个维度 void add(int x, int y, int v) { for(int i=x;i POJ 1195 - Mobile phones 1.5 逆序模型 来看一个给定$n$个元素的排列 $X0,X_1,X_2,…,X{n-2},X{n-1}$,对于某个 $X_i$ 元素，如果想知道以它为\"首\"的逆序对的对数( 形如$(X_iX_j)$ 的逆序对)，就是需要知道 $X{i+1}, … ,X{n-2}, X{n-1}$ 这个子序列中小于 $X_i$ 的元素的个数。 那么我们只需要对这个排列从后往前枚举，每次枚举到 $X_i$ 元素时，执行$cnt += sum(X_i-1)$，然后再执行$add(X_i, 1)$，$n$个元素枚举完毕，得到的$cnt$值就是我们要求的逆序数了。总的时间复杂度$O(nlogn)$ 注意，有些OJ题目给出$X_i$的取值范围很大，而树状数组的树状部分$C[...]$是建立在一个有点像位存储的数组的基础之上的，不是单纯的建立在输入数组之上。所以这时我们会用到离散化，离散化的过程一般为：将$a[...]$升序排列，$index[i]=j$，$i$为排序前元素的下标，$j$为排序后元素的下标。 LeetCode 面试题51 - 数组中的逆序对 同样是用树状数组求逆序数，如果对排列从前往后枚举，则算法过程会有些不同。如果数据不是很大，我们可以将数据一个个插入到树状数组中，每插入一个数（$add(X_i, 1)$），就统计比它小的数的个数$sum(X_i)$，那么$i-sum(X_i)$即为比$X_i$大的个数，也就是$X_i$的逆序数，$cnt+=i-sum(X_i)$. 同时需要注意是否需要先用到离散化。 POJ 2299 - Ultra-QuickSort HDU 1394 - Minimum Inversion Number 1.6 多重树状数组 不同于多维树状数组，这里，我们用到了多个树状数组进行处理 void add(int x, int v, int op){ for(int i=x;i POJ 1990 - MooFest 在多重树状数组下面，有个小分支的情况：有些时候不一定要把 $c[...]$ 数组增加一个维度（即开出两个树状数组来），可以清零后再复用一次，至于这种情况要仔细判断是否真的两个维度是前后执行的，如果是并行执行的，那么还是老老实实的把 $c[...]$ 数组增加一个维度 HDU 2492 - Ping pong 单调栈 单调栈有一个很经典的问题——下一个更大元素： 输入一个数组 nums，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1 比如说，输入一个数组 nums = [2,1,2,4,3]，返回数组 [4,2,4,-1,-1]。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1 这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人站成一列，如何求元素「2」的下一个更大元素呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下一个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。 我们直接看下模板代码 vector nextGreaterElement(vector nums) { int n = nums.length; // 存放答案的数组 vector res(n); stack s; // 倒着往栈里放 for (int i = n - 1; i >= 0; i--) { // 判定个子高矮 while (!s.empty() && s.top() 这个算法的时间复杂度不是那么直观，如果看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是\\mathcal O(n^2)，但是实际上这个算法的复杂度只有 \\mathcal O(n) 分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度 【经典问题】下一个更大元素 I 题目描述 496. 下一个更大元素 I 解法： 在模板的基础上加一个 key-value 映射即可 class Solution { private: unordered_map table; public: vector nextGreaterElement(vector& nums1, vector& nums2) { int n = nums2.size(); vector res(nums1.size()); stack s; for (int i = n - 1; i >= 0; i--) { while (!s.empty() && s.top() 【经典问题】739. 每日温度 题目描述 739. 每日温度 解法 现在问下一个更大元素索引和当前索引的差值，那么 stack 里面就 push 索引 class Solution { public: vector dailyTemperatures(vector& temperatures) { int n = temperatures.size(); vector ans(n); stack s; for (int i = n - 1; i >= 0; i--) { while (!s.empty() && temperatures[s.top()] 【经典问题】下一个更大元素 II 题目描述 503. 下一个更大元素 II 解法 环形数组常用的办法就是取余。取余的话是在一个数组内转圈，如何让数组尾部的元素能够看到数组头部的元素呢？数组长度翻倍（如下图所示），但是这里并不需要真的翻倍数组长度，通过取余即可 class Solution { public: vector nextGreaterElements(vector& nums) { int n = nums.size(); vector res(n); stack s; for (int i = 2 * n - 1; i >= 0; i--) { while (!s.empty() && s.top() 单调队列 举个例子, class MonotonicQueue { //单调队列（从大到小） public: deque que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop (int value) { if (!que.empty() && value == que.front()) { que.pop_front(); } } // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push (int value) { while (!que.empty() && value > que.back()) { que.pop_back(); } que.push_back(value); } // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() { return que.front(); } }; 【经典问题】滑动窗口最大值 题目描述 239. 滑动窗口最大值 解法 class MonotonicQueue{ ... }; class Solution { public: vector maxSlidingWindow(vector& nums, int k) { MonotonicQueue mq; vector res; for (int i = 0; i 【经典问题】队列的最大值 题目描述 面试题59 - II. 队列的最大值 解法 唯一不同的是 pop_front，题目中采取的是队列的 pop_front 和 MonotonicQueue 的 pop_front 有所不同。我们可以维护一个普通队列，value = queue.pop(); MonotonicQueue.pop_front(value) 即可 class MaxQueue { private: deque dq; queue q; public: MaxQueue() { } int max_value() { if (dq.empty()) return -1; return dq.front(); } void push_back(int value) { while (!dq.empty() && value > dq.back()) { dq.pop_back(); } dq.push_back(value); q.push(value); } int pop_front() { if (q.empty()) return -1; int ans = q.front(); q.pop(); if (!dq.empty() && ans == dq.front()) dq.pop_front(); return ans; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj->max_value(); * obj->push_back(value); * int param_3 = obj->pop_front(); */ 字典树（前缀树、Trie） 【经典问题】实现 Trie (前缀树) 题目描述 208. 实现 Trie (前缀树) 解法 Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段： 指向子节点的指针数组 $\\textit{next}$。对于本题而言，数组长度为 $26$，即小写英文字母的数量。此时 $\\textit{next}[0]$ 对应小写字母 $a$，$\\textit{next}[1]$ 对应小写字母 $b$，…，$\\textit{next}[25]$ 对应小写字母 $z$ 布尔字段 $\\textit{isEnd}$，表示该节点是否为字符串的结尾 如下图所示是一个包含 $\\textit{sea, sells, she}$ 的字典树 字典树的数据结构如下，包含了三种常用的操作 insert，search，startsWith class Trie { private: bool isEnd; Trie* next[26]; public: /** Initialize your data structure here. */ Trie() { isEnd = false; memset(next, 0, sizeof(next)); } /** Inserts a word into the trie. */ void insert(string word) { Trie* node = this; for(auto c: word) { if(node->next[c-'a']==NULL) node->next[c-'a'] = new Trie(); node = node->next[c-'a']; } node->isEnd = true; } /** Returns if the word is in the trie. */ bool search(string word) { Trie* node = this; for(auto c: word) { node = node->next[c-'a']; if(node==NULL) return false; } return node->isEnd; } /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) { Trie* node = this; for(auto c: prefix) { node = node->next[c-'a']; if(node==NULL) return false; } return true; } }; /** * Your Trie object will be instantiated and called as such: * Trie* obj = new Trie(); * obj->insert(word); * bool param_2 = obj->search(word); * bool param_3 = obj->startsWith(prefix); * * or: * Trie trie; * bool param_4 = trie.search(word) */ 下面是一棵我们建模的字典树，注意字符并不标记在节点上 LeetCode 208 的解法可以作为 Trie 的一种模板，另一种的模板如下 from collections import defaultdict from typing import Dict, Iterable, List, Optional class TrieNode: __slots__ = (\"wordCount\", \"preCount\", \"children\") def __init__(self): self.wordCount = 0 # 当前结点结束的字符串的数量 self.preCount = 0 # 当前结点作为前缀的字符串的数量 self.children: Dict[str, TrieNode] = defaultdict(TrieNode) class Trie: __slots__ = \"root\" def __init__(self, words: Optional[Iterable[str]] = None): self.root = TrieNode() for word in words or (): self.insert(word) def insert(self, s: str) -> None: if not s: return node = self.root for char in s: node = node.children[char] node.preCount += 1 node.wordCount += 1 def remove(self, s: str) -> None: \"\"\" 从前缀树中移除1个s 需要保证s在前缀树中 \"\"\" if not s: return node = self.root for char in s: if char not in node.children: raise ValueError(f\"word {s} not in trie\") if node.children[char].preCount == 1: del node.children[char] return node = node.children[char] node.preCount -= 1 node.wordCount -= 1 def countWord(self, s: str) -> List[int]: \"\"\" 对s的每个非空前缀pre,返回trie中有多少个等于pre的单词 假设 s = app，返回 [n1, n2, n3], n1 是 trie 中以 a 为单词的数量，n2 是 trie 中以 ap 为单词的数量，n3 是 trie 中以 app 为单词的数量 \"\"\" if not s: return [] res = [] node = self.root for char in s: if char not in node.children: return [] node = node.children[char] res.append(node.wordCount) return res def countWordStartsWith(self, s: str) -> List[int]: \"\"\" 对s的每个非空前缀pre,返回trie中有多少个单词以pre为前缀 假设 s = app，返回 [n1, n2, n3], n1 是 trie 中以 a 为前缀的数量，n2 是 trie 中以 ap 为前缀的数量，n3 是 trie 中 app 为前缀的数量 \"\"\" if not s: return [] res = [] node = self.root for char in s: if char not in node.children: return [] node = node.children[char] res.append(node.preCount) return res 【经典问题】添加与搜索单词 - 数据结构设计 题目描述 211. 添加与搜索单词 - 数据结构设计 解法 既然在 search 的过程中出现了通配符，那就通过枚举通配符再回溯即可，在树中的回溯也就是 DFS struct TrieNode { bool isEnd; vector next; TrieNode() { this->isEnd = false; this->next = vector(26, nullptr); } }; class WordDictionary { private: TrieNode* root; public: WordDictionary() { root = new TrieNode(); } void addWord(string word) { auto node = root; for (auto c : word) { if (node->next[c - 'a'] == nullptr) node->next[c- 'a'] = new TrieNode(); node = node->next[c - 'a']; } node->isEnd = true; } bool search(string word) { return dfs(root, word, 0); } bool dfs(TrieNode* node, string word, int i) { if (i == word.size()) { return node->isEnd; } auto c = word[i]; if ('a' next[c - 'a']; if (node != nullptr && dfs(node, word, i + 1)) return true; } else { for (auto n: node->next) { if (n != nullptr && dfs(n, word, i + 1)) return true; } } return false; } }; /** * Your WordDictionary object will be instantiated and called as such: * WordDictionary* obj = new WordDictionary(); * obj->addWord(word); * bool param_2 = obj->search(word); */ 【经典问题】单词替换 题目描述 648. 单词替换 解法 前面一道题是变换一下 search 的操作，这道题是变化 startsWith 的操作 struct TrieNode { bool isEnd; vector next; TrieNode() { this->isEnd = false; this->next = vector(26, nullptr); } }; class Trie { private: TrieNode* root; public: Trie () { root = new TrieNode(); } void insert(string s) { auto node = root; for (auto c: s){ if (node->next[c - 'a'] == nullptr) node->next[c - 'a'] = new TrieNode(); node = node->next[c - 'a']; } node->isEnd = true; } string findPrefix(string s) { string prefix = \"\"; auto node = root; for (auto c: s) { node = node->next[c - 'a']; if (node == nullptr) return s; prefix += c; if (node->isEnd) return prefix; } return prefix; } }; class Solution { public: string replaceWords(vector& dictionary, string sentence) { Trie* t = new Trie(); for (auto d: dictionary) t->insert(d); vector words = split(sentence, ' '); for (auto& w: words) { w = t->findPrefix(w); // cout split(string &str, char ch) { int pos = 0; int start = 0; vector ret; while (pos 【经典问题】677. 键值映射 题目描述 677. 键值映射 解法一：Trie + DFS 还是在 startsWith 操作上做变化，我们先找到前缀在 Trie 中的节点，然后 DFS 遍历子树 struct TrieNode { int val; vector next; TrieNode () { this->val = 0; this->next = vector(26, nullptr); } }; class MapSum { private: TrieNode* root; public: MapSum() { root = new TrieNode(); } void insert(string key, int val) { auto node = root; for (auto c: key) { if (node->next[c - 'a'] == nullptr) node->next[c - 'a'] = new TrieNode(); node = node->next[c - 'a']; } node->val = val; } int sum(string prefix) { auto node = root; for (auto c: prefix) { node = node->next[c - 'a']; if (node == nullptr) return 0; } int ans = 0; dfs(node, ans); return ans; } void dfs(TrieNode* node, int& sum) { sum += node->val; for (auto n: node->next) { if (n != nullptr) { dfs(n, sum); } } } }; /** * Your MapSum object will be instantiated and called as such: * MapSum* obj = new MapSum(); * obj->insert(key,val); * int param_2 = obj->sum(prefix); */ 解法二：Trie + Hash 这里可以通过 hash table 进行一个很巧妙的处理， 如果 key 第一次出现，那么就在 hash table 和 Trie（node->val = val）中记录下 val 如果 key 不是第一次出现，那么就能得到一个增量 \\Delta=val-\\text{hash}[key]，用这个增量来更新 Trie 中节点的值 node->val += delta 这时候，你会发现在 Trie 中每个结点都更新一下 val 有个好处，不用再在匹配前缀之后进行 DFS，而是直接可以根据前缀匹配到的节点直接返回 struct TrieNode { int val; vector next; TrieNode () { this->val = 0; this->next = vector(26, nullptr); } }; class MapSum { private: TrieNode* root; unordered_map hash_table; public: MapSum() { root = new TrieNode(); } void insert(string key, int val) { int delta = val; if (hash_table.count(key)) { delta -= hash_table[key]; } hash_table[key] = val; auto node = root; for (auto c: key) { if (node->next[c - 'a'] == nullptr) node->next[c - 'a'] = new TrieNode(); node = node->next[c - 'a']; node->val += delta; } } int sum(string prefix) { auto node = root; for (auto c: prefix) { node = node->next[c - 'a']; if (node == nullptr) return 0; } return node->val; } }; /** * Your MapSum object will be instantiated and called as such: * MapSum* obj = new MapSum(); * obj->insert(key,val); * int param_2 = obj->sum(prefix); */ "},"Part Five-高级算法/高级算法.html":{"url":"Part Five-高级算法/高级算法.html","title":"Part Five-高级算法","keywords":"","body":"求强力连通分量——Tarjan算法 Tarjan算法时用来求强连通分量的，它基于一种DFS的算法，每个强连通分量为搜索树的一颗子树 void tarjan(int k){ low[k] = dfn[k] = ++t; f[k] = true; // f[]代表该结点已经入栈 s.push(k); for(int i=fst[k];i!=-1;i=nex[i]){ if(!dfn[v[i]]){ tarjan(v[i]); low[k] = min(low[k],low[v[i]]); } else{ if(f[v[i]]) low[k] = min(low[k], dfn[v[i]]); } } if(low[k]==dfn[k]){ f[k] = false; scc[k] = ++cnt; // cnt记录强连通分量个数，ssc表示k在第cnt个强连通分中 ssize[cnt] = 1; // ssize记录第cnt个强连通分量的成员数 while(s.top()!=k){ scc[s.top()] = cnt; f[s.top()] = false; ssize[cnt]++; s.pop(); } s.pop(); } return; } 洛谷 P2341 - 受欢迎的牛 Reference Tarjan算法 详解+心得 Tarjan 算法[有向图强连通分量] Tarjan算法 最简单，详细的tarjan算法讲解 换根 DP 【经典问题】统计可能的树根数目 题目描述 6314. 统计可能的树根数目 解法 简单的想法呢，就是把每棵树作为根节点的情况枚举出来，然后去对照一遍 guesses，2 过于暴力 注意到，如果节点 x 和 y 之间有边，那么从「以 x 为根的树」变成「以 y 为根的树」，就只有 [x, y] 和 [y, x] 这两个猜测的正确性变了，其余猜测的正确性不变 因此，从 0 出发，再次 DFS 这棵树（reroot），从节点 x 递归到节点 y 时： 如果有猜测 [x, y]，那么猜对次数减一； 如果有猜测 [y, x]，那么猜对次数加一。 DFS 的同时，统计猜对次数 \\ge k 的节点个数，即为答案。 这个套路叫做『换根 DP』 class Solution { private: vector> g; unordered_set s; int ans = 0, cnt0 = 0; public: int rootCount(vector>& edges, vector>& guesses, int k) { g.resize(edges.size() + 1); for (auto e: edges) { int x = e[0], y = e[1]; g[x].push_back(y); g[y].push_back(x); } for (auto gue: guesses) { s.insert((long)gue[0] = k; // 此时 cnt 就是以 x 为根时的猜测对次数 for (int y: g[x]) { if (y != father){ reroot(y, x, cnt - s.count((long) x "},"Part Six-刷题笔记/牛客刷题笔记.html":{"url":"Part Six-刷题笔记/牛客刷题笔记.html","title":"牛客刷题笔记","keywords":"","body":"模拟 字符串的展开 题目描述 字符串的展开 解法 这道题就是条件判断有点多，我们依次来看下。我们设计一个 interpreter 函数来解释字符串中遇到的 - 首先，- 是否需要解读？如果一边是数字一边是字母，那么不需要。如果两边同为数字（字母），但右边不大于左边，那么也不需要解读 if(! ((isalpha(s) && isalpha(e) && s 其次，需要解读，但是返回空字符串。这个判断很简单，如下 if (e - s == 1) return \"\"; 接下来的情况，- 全部解读为对应的区间内的字符，即 s-w → stuvw，或4-9 → 456789 开始依次判断控制，先满足 p2，最后是 p3，至此 - 解读完毕 #include #include #include using namespace std; string interpreter(char s, char e, int p1, int p2, int p3){ if (e - s == 1) return \"\"; if(! ((isalpha(s) && isalpha(e) && s > p1 >> p2 >> p3; string s; cin >> s; string ans = \"\"; for (int i = 0; i = 0 && i + 1 图 BFS 小A与小B 题目描述 小A与小B 解法 先解释一下怎样算能遇到，如果一个人走到的点是另一个人曾经走过的点，则他两就算是可以相遇的 对于样例，也就是如上所示的 3 步，两人在最左上的点相遇 解法很简单就是 BFS，注意这里控制 BFS 循环的是时间。所以在一个时间点里面，C 走一次，D 走两次 说一个常用技巧，如何控制移动方向。竖着看，{dx[0], dy[0]} 表示右移一各，C 考虑前 4 组元素，D 考虑整个数组元素 const int dx[]={1,0,-1,0,1,1,-1,-1}; const int dy[]={0,1,0,-1,1,-1,1,-1}; #include #include using namespace std; const int dx[] = {1, 0, -1, 0, 1, 1, -1, -1,}; const int dy[] = {0, 1, 0, -1, 1, -1, 1, -1}; int n, m; char maze[1005][1005]; bool vis[2][1005][1005]; struct node { int x, y; }; queue q[2]; bool check_bfs(int person){ int q_size = q[person].size(); for (int k = 0; k n || new_y m || maze[new_x][new_y] == '#' || vis[person][new_x][new_y]) continue; if (vis[person^1][new_x][new_y]) return true; q[person].push((node){new_x, new_y}); vis[person][new_x][new_y] = 1; } } return false; } int main() { cin >> n >> m; for (int i = 1; i > maze[i][j]; if (maze[i][j] == 'C') { q[0].push((node){i, j}); vis[0][i][j] = 1; } if (maze[i][j] == 'D') { q[1].push((node){i, j}); vis[1][i][j] = 1; } } } int min_t = 0; bool meet = false; while (!q[0].empty() || !q[1].empty()) { meet = 0; min_t++; if (!q[0].empty() && check_bfs(0)) { meet = true; break; } // D 可以走两步 if (!q[1].empty() && check_bfs(1)) { meet = true; break; } if (!q[1].empty() && check_bfs(1)) { meet = true; break; } } if (meet) { cout DP 最大子矩阵 题目描述 最大子矩阵 解法 我们这里要用到前缀和来 这道题有一个特殊的地方 1 ≤ m ≤ 2，也就是说最多我们也只有两列数据要处理 那么我们先问一列的情况怎么处理？如下，dp[i][k] 表示了到数组位置 i 选 k 个段的最大和，sum[i] - sum[l] 是前缀和的知识 for (int l = 0; l 那么两列怎么处理呢？很简单嘛，假如说只在一列选区间，两种情况 // 当仅选取第一列的某段区间时 dp[i][j][k] = max(dp[i][j][k], dp[l][j][k-1]+sum[i][1]-sum[l-1][1]) // 当仅选取第二列的某段区间时 dp[i][j][k] = max(dp[i][j][k], dp[i][l][k-1]+sum[j][2]-sum[l-1][2]) 那两列都选，两列都不选的情况呢？ // 两列都不选 dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]) // i == j 时，两列都选 dp[i][j][k]=max(dp[i][j][k], dp[l][l][k] + sum[i][1] + sum[i][2] - sum[l-1][1] - sum[l-1][2]) 搞定，所有转移情况都已经列出来了 #include using namespace std; #define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); //代码预处理区 const int MAX = 1e2 + 7; int n, m, num; int sum[MAX][2], dp[MAX][MAX][17]; //全局变量区 int main() { IOS; cin >> n >> m >> num; for (int i = 1; i > sum[i][j]; sum[i][j] += sum[i - 1][j]; } for (int i = 1; i 数学考试 题目描述 数学考试 这里重新翻一下题目，出的啥玩意啊，分数还有负数的情况？不连续也描述的不准确 给定一个长度为 $n$ 的整数列，希望从中选出两个不相交的长度为 $k$ 的子数组，要求满足两个子数组和最大 解法 这道题还是 DP + 前缀和 我们用两次 DP 去求 $i$ 左边最大的子数组和右边的子数组，左边的情况很好处理 max_left = max(max_left, presum[i] - presum[i - k]) // i >= k 左边取到最大后，确定右边 ans = max(ans, max_left + presum[i + k] - presum[i]) 完整代码如下所示 #include using namespace std; vector presum(200005, 0); int main(){ int t; cin >> t; while (t--){ int n, k; cin >> n >> k; long long ans = -1e18, left_region = -1e18; for (int i = 1; i > presum[i]; presum[i] += presum[i - 1]; } for (int i = k; i + k 树 小 y 的树 题目描述 小y的树 解法 我们换个思维，计算任意两个结点之间距离的和其实就相当于计算树上每条边的贡献，也即这一条边会被走过多少次 对于某一层的边，它们的贡献是相同，取一条边研究即可 有个 tricks 要注意，取模的减法相减后要先加上模之后再取模 #include #include using namespace std; const int max_n = 2e6 + 50; long long levelNodes[max_n]; long long topDown[max_n]; long long n, k; int mod = 1e9 + 7; int main(){ cin >> n >> k; levelNodes[1] = 1, topDown[1] = 1; for (int i = 2; i "},"Part Six-刷题笔记/LC刷题笔记.html":{"url":"Part Six-刷题笔记/LC刷题笔记.html","title":"LeetCode 算题笔记","keywords":"","body":"870. 优势洗牌 题目描述 870. 优势洗牌 解法 这道题其实就是田忌赛马，只要比不过就拿个垫底的去送人头就是，唯一的技巧就在双指针处理送人头 class Solution { public: vector advantageCount(vector& nums1, vector& nums2) { int n = nums1.size(); vector> hash; vector res(n, 0) ; for (int i = 0; i (nums2[i], i)); } sort(hash.begin(), hash.end(),[](const pair& a1, const pair& a2){ return a1.first > a2.first; }); sort(nums1.begin(), nums1.end()); int left = 0, right = n - 1; for (auto a: hash){ int val = a.first, i = a.second; if (val 1652. 拆炸弹 题目描述 1652. 拆炸弹 解法 这道题其实就是一个 2 * n 的前缀和，对于循环数组我们一般都会想到 2 * n 的处理，但是，2 * n 没必要在原数组操作，而是利用 \\text{mod} 运算生成一个 2 * n 大小的前缀和数组 此时，若有 k ，先将位置 i 往后进行 n 个偏移（即位置 i + n），随后可知对应前缀和的区为 [i + n - 1, i + n + k - 1] class Solution { public: vector decrypt(vector& code, int k) { int n = code.size(); vector res(n, 0); if(k == 0) return res; vector presum(2 * n + 5, 0); for (int i = 1; i 316. 去除重复字母 题目描述 316. 去除重复字母 解法 题目有三个要求， 去重 字符出现的相对顺序不变 在所有符合上一条要求的去重字符串中，字典序最小的作为最终结果 意思就是说，输入字符串 s = \"babc\"，去重且符合相对位置的字符串有两个，分别是 \"bac\" 和 \"abc\"，但是我们的算法得返回 \"abc\"，因为它的字典序更小 前两个要求好解决，用栈就可以实现，这时候我们可以得到 \"bac\" class Solution { public: string removeDuplicateLetters(string s) { int n = s.size(); stack st; vector visited(256, 0); for (auto c: s){ if (visited[c]) continue; st.push(c); visited[c] = 1; } string res = \"\"; while(!st.empty()){ char tmp = st.top(); st.pop(); res += tmp; } reverse(res.begin(), res.end()); return res; } }; 要得到 \"bac\" 呢？ 在向栈 st 中插入字符 'a' 的这一刻，我们的算法需要知道，字符 'a' 的字典序和之前的两个字符 'b' 和 'c' 相比，谁大谁小？ 如果当前字符 'a' 比之前的字符字典序小，就有可能需要把前面的字符 pop 出栈，让 'a' 排在前面，对吧？但是这里还是有一个问题 假设 s = \"bcac\"，按照刚才的算法逻辑，返回的结果是 \"ac\"，而正确答案应该是 \"bac\"，分析一下这是怎么回事？ 很容易发现，因为 s 中只有唯一一个 'b'，即便字符 'a' 的字典序比字符 'b' 要小，字符 'b' 也不应该被 pop 出去 那么，在 st.top() > c 时才会 pop 元素，这时候应该分两种情况： 情况一，如果 st.top() 这个字符之后还会出现，那么可以把它 pop 出去，反正后面还有嘛，后面再 push 到栈里，刚好符合字典序的要求 情况二，如果st.top()这个字符之后不会出现了，前面也说了栈中不会存在重复的元素，那么就不能把它 pop 出去，否则你就永远失去了这个字符。 回到 s = \"bcac\" 的例子，插入字符 'a' 的时候，发现前面的字符 'c' 的字典序比 'a' 大，且在 'a' 之后还存在字符 'c'，那么栈顶的这个 'c' 就会被 pop 掉。 while 循环继续判断，发现前面的字符 'b' 的字典序还是比 'a' 大，但是在 'a' 之后再没有字符 'b' 了，所以不应该把 'b' pop 出去 那么关键就在于，如何让算法知道字符 'a' 之后有几个 'b' 有几个 'c' class Solution { public: string removeDuplicateLetters(string s) { int n = s.size(); stack st; vector cnt(256, 0); vector visited(256, 0); for (auto c: s) cnt[c]++; for (auto c: s){ cnt[c]--; if (visited[c]) continue; while(!st.empty() && st.top() > c){ if (cnt[st.top()] == 0) break; visited[st.top()] = 0; st.pop(); } st.push(c); visited[c] = 1; } string res = \"\"; while(!st.empty()){ char tmp = st.top(); st.pop(); res += tmp; } reverse(res.begin(), res.end()); return res; } }; 1784. 检查二进制字符串字段 题目描述 1784. 检查二进制字符串字段 解法一 三行，直接模拟 class Solution { public: bool checkOnesSegment(string s) { int ans = 1; for (int i = 1; i 解法二 还有一种解法，一行，但是 比较巧一点，题目所描述的情况的都包含 01 串，同时，不包含 01 串的二进制字符串有且仅有上面两种，所以我们在 s 中寻找是否存在 01 串即可 class Solution { public: bool checkOnesSegment(string s) { return s.find(\"01\") == string::npos; } }; 1250. 检查「好数组」 题目描述 1250. 检查「好数组」 解法 【裴蜀定理】 class Solution { public: bool isGoodArray(vector& nums) { int flag = nums[0]; for (int i = 1; i 1139. 最大的以 1 为边界的正方形 题目描述 1139. 最大的以 1 为边界的正方形 解法一：二维前缀和 二维前缀和的运用很巧妙，在网格中我们可以得到任意一个正方形的和，怎么判断这个正方形是边界全为 1 的呢？正方形里面一个取小一圈的正方形，两个正方形区域和的差值应该正好等于边界上 1 的和 class Solution { public: int largest1BorderedSquare(vector>& grid) { int m = grid.size(), n = grid[0].size(); vector> preSum(m + 1, vector(n + 1)); int ans = 0; for (int i = 1; i = 0 && j - k >=0; k++) { int s1 = preSum[i][j] - preSum[i - k][j] -preSum[i][j - k] + preSum[i - k][j - k]; int s2 = preSum[i - 1][j - 1] - preSum[i - k + 1][j - 1] - preSum[i - 1][j - k + 1] + preSum[i - k + 1][j - k + 1]; int t = k - 2; if (s1 - s2 == k * k - t * t) ans = max(ans, k * k); } } } return ans; } }; 6360. 最小无法得到的或值 题目描述 6360. 最小无法得到的或值 解法： 或运算只能将二进制中的 0 变成 1，因此，如果 $2^k$ 是可表达的，那么 nums 中一定存在 $2^k$ class Solution { public: int minImpossibleOR(vector& nums) { map cnt; for(auto i: nums) cnt[i]++; for(int i = 1; ; i 2570. 合并两个二维数组 - 求和法 题目描述 2570. 合并两个二维数组 - 求和法 解法：双指针 class Solution { public: vector> mergeArrays(vector>& nums1, vector>& nums2) { int p1 = 0, p2 = 0; int n = nums1.size(), m = nums2.size(); vector> ans; while (p1 2571. 将整数减少到零需要的最少操作数 题目描述 2571. 将整数减少到零需要的最少操作数 解法： 先说几个位操作的技巧 【lowbit】 lowbit(x) 取 x 在二进制表示下最低位的 1 以及它后面的 0 构成的数值 lowbit(x) = x & (-x) x = x - lowbit(x); // 去掉最低位的 1 基于 lowbit 的运算，我们可以贪心考虑将连续的 1 加上 lowbit，不连续的 1 减去 lowbit，判断连续的 1 代码如下 x & (lowbit 位运算 x 是否是 2 的幂次 x & (x - 1) 完整代码如下 class Solution { public: int minOperations(int n) { int ans = 1; while (n & (n - 1)) { int lowbit = n & (-n); if (n & (lowbit 2572. 无平方子集计数 题目描述 2572. 无平方子集计数 解法：状态压缩 DP 这道题要注意下提示 1 ，前 30 的数，只有 10 个质数 vector prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}。换句话说，nums[i] 是平方因子数，只可能是 prime 里面的平方数够成的，如 28 =2 2 7 维护 $f(i, m)$ 表示前 $i$ 个数的子集中，质因数出现情况用二进制数 $m$ 表示的子集的个数。注意是用二进制数表示的质因数组合，即 0000110100 表示组合中出现 5, 11, 13 那么状态转移方程即是 \r f[i][j | msk] = (f[i][j | msk] + f[i - 1][j])\r 同时注意，要求 $msk\\ \\&\\ msk' = 0$，因为出现过的质因数不能再次出现，否则子集乘积会变成平方数 最后，优化一下空间复杂度，由于第 $i$ 轮的 dp 状态和第 $i-1$ 轮相比，新一轮的方案 $j$ 中只满足 j & msk == msk 的方案才会增加，其他方案的总数不变，而且增加的量全部来源于不变的量，所以可以直接取消 f 的第一维,代码其他部分可以完全不变 class Solution { private: const int MAXK = 10; const int MOD = 1e9 + 7; vector prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29}; bool check(int x) { for (int i = 0; i & nums) { long long f[1 2573. 找出对应 LCP 矩阵的字符串 题目描述 2573. 找出对应 LCP 矩阵的字符串 解法： 首先，要知道到底什么是 LCP 矩阵，比如说示例 1 的字符串 abab，s[0...n] = abab 和 s[2...n] =ab，所以 lcp[0][2] = 2 如果要构造字典序最小的 s，那么肯定从 s[0] = a 开始填 那么，s[0] = a 时，根据 lcp[0] 还有哪些是 a 哪些不能是 a 呢？ 根据 LCP 的定义，lcp[0][i]>0 的一定是 a，lcp[0][i]=0 的一定不是 a 现在流程很明确了 先填 a， 然后根据 LCP 的一行把填 a 的位置补满 然后填 b，根据LCP 的一行把填 b 的位置补满 如此循环，直到 26 个字母用完 这样，构造的部分就结束了。但是，有两种情况，一是构造出来的字符串还有位置没填上字符，二是构造的字符串的 LPC 和提供的 LPC 不一致，原因很简单可能输入的 LCP 是一个不合法的矩阵 情况一的检查很容易 情况二的检查利用 LCP 的DP 转移方程，首先明确边界条件 (lcp[i][n−1],lcp[n−1][i])，转移方程如下 \r lcp[i][j]=lcp[i+1][j+1]+1\\ 若\\ s[i]==s[j]\\ 否则\\ lcp[i][j]=0\\\r class Solution { public: string findTheString(vector>& lcp) { int i = 0, n = lcp.size(); string s(n, '#'); for (char c = 'a'; c =0; i--) { for (int j = n - 1; j >= 0; j--) { int actualLCP = s[i] != s[j] ? 0 : i == n - 1 || j == n - 1 ? 1 : lcp[i + 1][j + 1] + 1; if (lcp[i][j] !=actualLCP) return \"\"; } } return s; } }; 89. 格雷编码 题目描述 89. 格雷编码 解法：镜射排列 class Solution { public: vector grayCode(int n) { vector ans; ans.push_back(0); for (int i = 0; i = 0; j--) { ans.push_back(ans[j] ^ (1 1238. 循环码排列 题目描述 1238. 循环码排列 解法 先看 89 题，再看 1238 就很简单了，先按照格雷码生成数组，然后再根据 start 循环排列一下数组就好 class Solution { public: vector circularPermutation(int n, int start) { int s = 0; vector gray_code = {0}; for (int i = 0; i = 0; j--){ int num = gray_code[j] ^ (1 ans; for (int i = s; i 6368. 找出字符串的可整除数组 题目描述 6368. 找出字符串的可整除数组 解法 如果单纯利用 num = num * 10 + d 去对 m 取余的话，num 会远大于 long long 可以表示的范围，那么这里就有一个技巧了，num = (num*10+d)\\ \\text{mod}\\ m class Solution { public: vector divisibilityArray(string word, int m) { long long num = 0; vector ans(word.size(), 0); for (int i = 0; i 6367. 求出最多标记下标 题目描述 6367. 求出最多标记下标 解法：二分法 先明确题目两个地方，一是标记过的一对就不可以再和其他数配对标记，二是一组标记包含两个小标，所以答案时可标记组数 * 2 将数组排序后就可以分为两部分，且如果 2*nums[0] \\leq nums[j]，那么下一组标记 nums[1] 只能从下标大于 j 的数去找 class Solution { public: int maxNumOfMarkedIndices(vector& nums) { sort(nums.begin(), nums.end()); int i = 0, n = nums.size(); for (int j = (n + 1) / 2; j 6366. 在网格图中访问一个格子的最少时间 题目描述 6366. 在网格图中访问一个格子的最少时间 解法：Dijkstra 定义 dis[i][j] 为到达 (i, j) 的最小时间，如果没有别的约束，那么每条边的边权可以视作 1，根据 Dijkstra 算法就可以算出答案 根据题意，dis[i][j] 至少要是 grid[i][j] 但是这个题目中有一个比较神奇的地方，如果当前时间还不满足，可以反复横跳来凑够时间 那么在可以反复横跳的情况下，到达一个格子的时间的奇偶性是不变的，那么 dis[i][j] 应当与 i+j 的奇偶性相同 算上上面两个约束，就可以计算出正确结果了 class Solution { private: public: int minimumTime(vector>& grid) { int n = grid.size(), m = grid[0].size(); if (grid[0][1] > 1 && grid[1][0] > 1) return -1; vector> dis(n, vector(m, INT_MAX)); dis[0][0] = 0; priority_queue, vector>, greater<>> pq; pq.emplace(0, 0, 0); for (;;) { auto[d, i, j] = pq.top(); pq.pop(); if (i == n - 1 && j == m - 1) return d; for (auto &q:dirs) { int x = i + q[0], y = j + q[1]; if (0 146. LRU 缓存机制 题目描述 146. LRU 缓存机制 解法 LRU 全称 Least Recently Used，那么在 get 和 put 都要注意对队列进行更新 LRU 采用哈希链表的数据结构，哈希中存储关键字和关键字在双向链表中的位置 class LRUCache { public: LRUCache(int capacity):capacity_(capacity){ } int get(int key) { if(hash_.find(key)==hash_.end()) return -1; else { // 把刚访问的(key, value)放在链表头 int value = hash_[key]->second; ls_.erase(hash_[key]); ls_.push_front(make_pair(key, value)); // 更新(key, value)在链表中的位置 hash_[key] = ls_.begin(); return value; } } void put(int key, int value) { if(hash_.find(key)!=hash_.end()) ls_.erase(hash_[key]); if(ls_.size()>=capacity_) { hash_.erase(ls_.back().first); ls_.pop_back(); } ls_.push_front(make_pair(key, value)); hash_[key] = ls_.begin(); } private: int capacity_; list> ls_; unordered_map>::iterator> hash_; }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ 460. LFU缓存 题目描述 460. LFU缓存 解法一：哈希表 + AVL 树 在 C++ 中 AVL 树采取 STL::set 实现 时间复杂度： get 时间复杂度 $O(\\log n)$，put 时间复杂度 $O(\\log n)$，操作的时间复杂度瓶颈在于平衡二叉树的插入删除均需要 $O(\\log n)$ 的时间 struct Node { int cnt; int time; int key, value; Node(int _cnt, int _time, int _key, int _value) : cnt(_cnt), time(_time), key(_key), value(_value) {} bool operator key_table; set S; public: LFUCache(int _capacity) { capacity = _capacity; time = 0; key_table.clear(); S.clear(); } int get(int key) { if (capacity == 0) return -1; auto it = key_table.find(key); if (it == key_table.end()) return -1; Node cache = it->second; S.erase(cache); cache.cnt += 1; cache.time = ++time; S.insert(cache); it->second = cache; return cache.value; } void put(int key, int value) { if (capacity == 0) return; auto it = key_table.find(key); if (it == key_table.end()) { if (key_table.size() == capacity) { key_table.erase(S.begin()->key); S.erase(S.begin()); } Node cache = Node(1, ++time, key, value); key_table.insert(make_pair(key, cache)); S.insert(cache); } else { Node cache = it->second; S.erase(cache); cache.cnt += 1; cache.time = ++time; cache.value = value; S.insert(cache); it->second = cache; } } }; /** * Your LFUCache object will be instantiated and called as such: * LFUCache* obj = new LFUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ 解法二：双哈希表 双哈希表的方式比起哈希 + AVL 树最大的好处就是将操作的时间复杂度降为了 \\mathcal O(1) 双哈希表一个 freq_table 记录 freq = n 的双向链表，一个 key_table 记录 key = k 的节点在 freq = n 的双向链表中的位置，具体如下 unordered_map> freq_table; unordered_map::iterator> key_table; 双哈希表中有两点需要注意的， 在双向链表中我们才用头插入的方式来维护一个时间序列 对于双向链表的操作，当双向链表为空时要记得释放 struct Node { int key, val, freq; Node(int _key,int _val,int _freq): key(_key), val(_val), freq(_freq){} }; class LFUCache { private: int minfreq, capacity; unordered_map> freq_table; unordered_map::iterator> key_table; public: LFUCache(int _capacity) { minfreq = 0; capacity = _capacity; key_table.clear(); freq_table.clear(); } int get(int key) { if (capacity == 0) return -1; auto it = key_table.find(key); if (it == key_table.end()) return -1; auto node_it = it->second; int val = node_it->val, freq = node_it->freq; freq_table[freq].erase(node_it); if (freq_table[freq].size() == 0) { freq_table.erase(freq); if (minfreq == freq) minfreq++; } freq_table[freq + 1].push_front(Node(key, val, freq + 1)); key_table[key] = freq_table[freq + 1].begin(); return val; } void put(int key, int value) { if (capacity == 0) return; auto it = key_table.find(key); if (it == key_table.end()) { if (key_table.size() == capacity) { auto it2 = freq_table[minfreq].back(); key_table.erase(it2.key); freq_table[minfreq].pop_back(); if (freq_table[minfreq].size() == 0) { freq_table.erase(minfreq); } } freq_table[1].push_front(Node(key, value, 1)); key_table[key] = freq_table[1].begin(); minfreq = 1; } else { auto node_it = it->second; int freq = node_it->freq; freq_table[freq].erase(node_it); if (freq_table[freq].size() == 0) { freq_table.erase(freq); if (minfreq == freq) minfreq++; } freq_table[freq + 1].push_front(Node(key, value, freq + 1)); key_table[key] = freq_table[freq + 1].begin(); } } }; /** * Your LFUCache object will be instantiated and called as such: * LFUCache* obj = new LFUCache(capacity); * int param_1 = obj->get(key); * obj->put(key,value); */ 6312. 最小和分割 题目描述 6312. 最小和分割 解法 神奇的地方就在于你给 num 的每个数按升序排列后还不能按着挑，要跳着挑才能组合出最小和 class Solution { public: int splitNum(int num) { string s = to_string(num); sort(s.begin(), s.end()); int nums[2]{}; for (int i = 0; i 6313. 统计将重叠区间合并成组的方案数 题目描述 6313. 统计将重叠区间合并成组的方案数 解法 假设我们合并完最终剩下 n 个不相交区间分为两组，那么最终的答案就是 2^n 问题在于我们有必要执行合并的操作吗？没必要，将 ranges 按照 start 升序排列，，同时维护区间右端点的最大值 maxR，如果存在 ranges[i][0] 那么说明该区间应该合并到上一个区间中，这时候不用更新 n，只用更新 maxR class Solution { public: const int mod = 1e9 +7; int countWays(vector>& ranges) { sort(ranges.begin(), ranges.end(), [](auto& a, auto& b) { return a[0] maxR) ans = ans * 2 % mod; maxR = max(maxR, ranges[i][1]); } return ans; } }; "},"Part Eight-数学相关/数学相关.html":{"url":"Part Eight-数学相关/数学相关.html","title":"Part Eight-数学相关","keywords":"","body":"快速幂 & 逆元 快速幂的原理十分简单 \r a^k=a^{2^0}\\times a^{2^1}\\times a^{2^2}\\times\\ldots\\times a^{2^x},\\ k=2^0+2^1+2^2+\\ldots+2^x\r [!danger|iconVisibility:hidden] 快速幂的代码如下 typedef long long ll; ll qmi(ll a,ll b,ll p) { ll ans = 1; while(b) { if(b & 1) ans = ans * a % p; a = a * a % p; b >>= 1; } return ans; } 我们先说一下逆元的概念 当 a\\cdot m \\equiv 1\\ (\\text{mod}\\ p)， m 即为 a 在 \\text{mod}\\ p 意义下的逆元（需要注意只有 a 和 p 互质，a 才有关于 p 的逆元） 在模运算中，没有 (a/b)\\ \\text{mod}\\ p=\\left((a\\ \\text{mod}\\ p) / (b\\ \\text{mod}\\ p)\\right)\\ \\text{mod}\\ p 这回事， 所以通过乘法逆元帮助我们将其转换为乘法形式，即 (a/b)\\ \\text{mod}\\ p=(a\\cdot x)\\ \\text{mod}\\ p，其中 x 表示 b 的逆元 既然有如此好事可以化除为乘，那怎么求 x 呢？ 首先 x 作为 b 的逆元，有 \r b\\cdot x\\ (\\text{mod}\\ p) \\equiv 1\r 又由于 b, p 互为质数，由费马小定理得 \r b^{(p-1)}=1\\ (\\text{mod}\\ p)\r 于是有 \r x=b^{(p-2)}\r [!danger|iconVisibility:hidden] 快速幂求逆元的代码如下 LL inverse(LL a, LL p) { return qmi(a, p - 2, p); } "},"Part Nine-语言模板/C++常用方法.html":{"url":"Part Nine-语言模板/C++常用方法.html","title":"C++","keywords":"","body":"vector max int max_ele = *max_element(v.begin(), v.end()); 记录时间 auto start = chrono::high_resolution_clock::now(); print(1, 2, 3, 4, 5, 6); auto end = chrono::high_resolution_clock::now(); auto cost_time = chrono::duration_cast(end - start).count(); "}}